\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Effective Go}
\chapter*{Effective Go}

\section*{Introduction}

Go is a new language. Although it borrows ideas from existing languages,
it has unusual properties that make effective Go programs different in
character from programs written in its relatives. A straightforward
translation of a C++ or Java program into Go is unlikely to produce a
satisfactory result---Java programs are written in Java, not Go. On the
other hand, thinking about the problem from a Go perspective could
produce a successful but quite different program. In other words, to
write Go well, it's important to understand its properties and idioms.
It's also important to know the established conventions for programming
in Go, such as naming, formatting, program construction, and so on, so
that programs you write will be easy for other Go programmers to
understand.

This document gives tips for writing clear, idiomatic Go code. It
augments the \href{/ref/spec}{language specification}, the
\href{http://tour.golang.org/}{Tour of Go}, and
\href{/doc/code.html}{How to Write Go Code}, all of which you should
read first.

\subsection*{Examples}

The \href{/src/pkg/}{Go package sources} are intended to serve not only
as the core library but also as examples of how to use the language. If
you have a question about how to approach a problem or how something
might be implemented, they can provide answers, ideas and background.

\section*{Formatting}

Formatting issues are the most contentious but the least consequential.
People can adapt to different formatting styles but it's better if they
don't have to, and less time is devoted to the topic if everyone adheres
to the same style. The problem is how to approach this Utopia without a
long prescriptive style guide.

With Go we take an unusual approach and let the machine take care of
most formatting issues. The \texttt{gofmt} program (also available as
\texttt{go fmt}, which operates at the package level rather than source
file level) reads a Go program and emits the source in a standard style
of indentation and vertical alignment, retaining and if necessary
reformatting comments. If you want to know how to handle some new layout
situation, run \texttt{gofmt}; if the answer doesn't seem right,
rearrange your program (or file a bug about \texttt{gofmt}), don't work
around it.

As an example, there's no need to spend time lining up the comments on
the fields of a structure. \texttt{Gofmt} will do that for you. Given
the declaration

\begin{Verbatim}[frame=single]
type T struct {
    name string // name of the object
    value int // its value
}
\end{Verbatim}

\texttt{gofmt} will line up the columns:

\begin{Verbatim}[frame=single]
type T struct {
    name    string // name of the object
    value   int    // its value
}
\end{Verbatim}

All Go code in the standard packages has been formatted with
\texttt{gofmt}.

Some formatting details remain. Very briefly,

\begin{description}
\item[Indentation]
We use tabs for indentation and \texttt{gofmt} emits them by default.
Use spaces only if you must.
\item[Line length]
Go has no line length limit. Don't worry about overflowing a punched
card. If a line feels too long, wrap it and indent with an extra tab.
\item[Parentheses]
Go needs fewer parentheses: control structures (\texttt{if},
\texttt{for}, \texttt{switch}) do not have parentheses in their syntax.
Also, the operator precedence hierarchy is shorter and clearer, so

\begin{Verbatim}[frame=single]
x<<8 + y<<16
\end{Verbatim}

means what the spacing implies.
\end{description}

\section*{Commentary}

Go provides C-style \texttt{/* */} block comments and C++-style
\texttt{//} line comments. Line comments are the norm; block comments
appear mostly as package comments and are also useful to disable large
swaths of code.

The program---and web server---\texttt{godoc} processes Go source files
to extract documentation about the contents of the package. Comments
that appear before top-level declarations, with no intervening newlines,
are extracted along with the declaration to serve as explanatory text
for the item. The nature and style of these comments determines the
quality of the documentation \texttt{godoc} produces.

Every package should have a \emph{package comment}, a block comment
preceding the package clause. For multi-file packages, the package
comment only needs to be present in one file, and any one will do. The
package comment should introduce the package and provide information
relevant to the package as a whole. It will appear first on the
\texttt{godoc} page and should set up the detailed documentation that
follows.

\begin{Verbatim}[frame=single]
/*
    Package regexp implements a simple library for
    regular expressions.

    The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
\end{Verbatim}

If the package is simple, the package comment can be brief.

\begin{Verbatim}[frame=single]
// Package path implements utility routines for
// manipulating slash-separated filename paths.
\end{Verbatim}

Comments do not need extra formatting such as banners of stars. The
generated output may not even be presented in a fixed-width font, so
don't depend on spacing for alignment---\texttt{godoc}, like
\texttt{gofmt}, takes care of that. The comments are uninterpreted plain
text, so HTML and other annotations such as \texttt{\_this\_} will
reproduce \emph{verbatim} and should not be used. Depending on the
context, \texttt{godoc} might not even reformat comments, so make sure
they look good straight up: use correct spelling, punctuation, and
sentence structure, fold long lines, and so on.

Inside a package, any comment immediately preceding a top-level
declaration serves as a \emph{doc comment} for that declaration. Every
exported (capitalized) name in a program should have a doc comment.

Doc comments work best as complete sentences, which allow a wide variety
of automated presentations. The first sentence should be a one-sentence
summary that starts with the name being declared.

\begin{Verbatim}[frame=single]
// Compile parses a regular expression and returns, if successful, a Regexp
// object that can be used to match against text.
func Compile(str string) (regexp *Regexp, err error) {
\end{Verbatim}

Go's declaration syntax allows grouping of declarations. A single doc
comment can introduce a group of related constants or variables. Since
the whole declaration is presented, such a comment can often be
perfunctory.

\begin{Verbatim}[frame=single]
// Error codes returned by failures to parse an expression.
var (
    ErrInternal      = errors.New("regexp: internal error")
    ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
    ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
    ...
)
\end{Verbatim}

Even for private names, grouping can also indicate relationships between
items, such as the fact that a set of variables is protected by a mutex.

\begin{Verbatim}[frame=single]
var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
\end{Verbatim}

\section*{Names}

Names are as important in Go as in any other language. In some cases
they even have semantic effect: for instance, the visibility of a name
outside a package is determined by whether its first character is upper
case. It's therefore worth spending a little time talking about naming
conventions in Go programs.

\subsection*{Package names}

When a package is imported, the package name becomes an accessor for the
contents. After

\begin{Verbatim}[frame=single]
import "bytes"
\end{Verbatim}

the importing package can talk about \texttt{bytes.Buffer}. It's helpful
if everyone using the package can use the same name to refer to its
contents, which implies that the package name should be good: short,
concise, evocative. By convention, packages are given lower case,
single-word names; there should be no need for underscores or mixedCaps.
Err on the side of brevity, since everyone using your package will be
typing that name. And don't worry about collisions \emph{a priori}. The
package name is only the default name for imports; it need not be unique
across all source code, and in the rare case of a collision the
importing package can choose a different name to use locally. In any
case, confusion is rare because the file name in the import determines
just which package is being used.

Another convention is that the package name is the base name of its
source directory; the package in \texttt{src/pkg/encoding/base64} is
imported as \texttt{"encoding/base64"} but has name \texttt{base64}, not
\texttt{encoding\_base64} and not \texttt{encodingBase64}.

The importer of a package will use the name to refer to its contents
(the \texttt{import .} notation is intended mostly for tests and other
unusual situations and should be avoided unless necessary), so exported
names in the package can use that fact to avoid stutter. For instance,
the buffered reader type in the \texttt{bufio} package is called
\texttt{Reader}, not \texttt{BufReader}, because users see it as
\texttt{bufio.Reader}, which is a clear, concise name. Moreover, because
imported entities are always addressed with their package name,
\texttt{bufio.Reader} does not conflict with \texttt{io.Reader}.
Similarly, the function to make new instances of
\texttt{ring.Ring}---which is the definition of a \emph{constructor} in
Go---would normally be called \texttt{NewRing}, but since \texttt{Ring}
is the only type exported by the package, and since the package is
called \texttt{ring}, it's called just \texttt{New}, which clients of
the package see as \texttt{ring.New}. Use the package structure to help
you choose good names.

Another short example is \texttt{once.Do}; \texttt{once.Do(setup)} reads
well and would not be improved by writing
\texttt{once.DoOrWaitUntilDone(setup)}. Long names don't automatically
make things more readable. If the name represents something intricate or
subtle, it's usually better to write a helpful doc comment than to
attempt to put all the information into the name.

\subsection*{Getters}

Go doesn't provide automatic support for getters and setters. There's
nothing wrong with providing getters and setters yourself, and it's
often appropriate to do so, but it's neither idiomatic nor necessary to
put \texttt{Get} into the getter's name. If you have a field called
\texttt{owner} (lower case, unexported), the getter method should be
called \texttt{Owner} (upper case, exported), not \texttt{GetOwner}. The
use of upper-case names for export provides the hook to discriminate the
field from the method. A setter function, if needed, will likely be
called \texttt{SetOwner}. Both names read well in practice:

\begin{Verbatim}[frame=single]
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
\end{Verbatim}

\subsection*{Interface names}

By convention, one-method interfaces are named by the method name plus
the -er suffix: \texttt{Reader}, \texttt{Writer}, \texttt{Formatter}
etc.

There are a number of such names and it's productive to honor them and
the function names they capture. \texttt{Read}, \texttt{Write},
\texttt{Close}, \texttt{Flush}, \texttt{String} and so on have canonical
signatures and meanings. To avoid confusion, don't give your method one
of those names unless it has the same signature and meaning. Conversely,
if your type implements a method with the same meaning as a method on a
well-known type, give it the same name and signature; call your
string-converter method \texttt{String} not \texttt{ToString}.

\subsection*{MixedCaps}

Finally, the convention in Go is to use \texttt{MixedCaps} or
\texttt{mixedCaps} rather than underscores to write multiword names.

\section*{Semicolons}

Like C, Go's formal grammar uses semicolons to terminate statements;
unlike C, those semicolons do not appear in the source. Instead the
lexer uses a simple rule to insert semicolons automatically as it scans,
so the input text is mostly free of them.

The rule is this. If the last token before a newline is an identifier
(which includes words like \texttt{int} and \texttt{float64}), a basic
literal such as a number or string constant, or one of the tokens

\begin{Verbatim}[frame=single]
break continue fallthrough return ++ -- ) }
\end{Verbatim}

the lexer always inserts a semicolon after the token. This could be
summarized as, ``if the newline comes after a token that could end a
statement, insert a semicolon''.

A semicolon can also be omitted immediately before a closing brace, so a
statement such as

\begin{Verbatim}[frame=single]
    go func() { for { dst <- <-src } }()
\end{Verbatim}

needs no semicolons. Idiomatic Go programs have semicolons only in
places such as \texttt{for} loop clauses, to separate the initializer,
condition, and continuation elements. They are also necessary to
separate multiple statements on a line, should you write code that way.

One caveat. You should never put the opening brace of a control
structure (\texttt{if}, \texttt{for}, \texttt{switch}, or
\texttt{select}) on the next line. If you do, a semicolon will be
inserted before the brace, which could cause unwanted effects. Write
them like this

\begin{Verbatim}[frame=single]
if i < f() {
    g()
}
\end{Verbatim}

not like this

\begin{Verbatim}[frame=single]
if i < f()  // wrong!
{           // wrong!
    g()
}
\end{Verbatim}

\section*{Control structures}

The control structures of Go are related to those of C but differ in
important ways. There is no \texttt{do} or \texttt{while} loop, only a
slightly generalized \texttt{for}; \texttt{switch} is more flexible;
\texttt{if} and \texttt{switch} accept an optional initialization
statement like that of \texttt{for}; and there are new control
structures including a type switch and a multiway communications
multiplexer, \texttt{select}. The syntax is also slightly different:
there are no parentheses and the bodies must always be brace-delimited.

\subsection*{If}

In Go a simple \texttt{if} looks like this:

\begin{Verbatim}[frame=single]
if x > 0 {
    return y
}
\end{Verbatim}

Mandatory braces encourage writing simple \texttt{if} statements on
multiple lines. It's good style to do so anyway, especially when the
body contains a control statement such as a \texttt{return} or
\texttt{break}.

Since \texttt{if} and \texttt{switch} accept an initialization
statement, it's common to see one used to set up a local variable.

\begin{Verbatim}[frame=single]
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
\end{Verbatim}

In the Go libraries, you'll find that when an \texttt{if} statement
doesn't flow into the next statement---that is, the body ends in
\texttt{break}, \texttt{continue}, \texttt{goto}, or
\texttt{return}---the unnecessary \texttt{else} is omitted.

\begin{Verbatim}[frame=single]
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
\end{Verbatim}

This is an example of a common situation where code must guard against a
sequence of error conditions. The code reads well if the successful flow
of control runs down the page, eliminating error cases as they arise.
Since error cases tend to end in \texttt{return} statements, the
resulting code needs no \texttt{else} statements.

\begin{Verbatim}[frame=single]
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
\end{Verbatim}

\subsection*{Redeclaration}

An aside: The last example in the previous section demonstrates a detail
of how the \texttt{:=} short declaration form works. The declaration
that calls \texttt{os.Open} reads,

\begin{Verbatim}[frame=single]
f, err := os.Open(name)
\end{Verbatim}

This statement declares two variables, \texttt{f} and \texttt{err}. A
few lines later, the call to \texttt{f.Stat} reads,

\begin{Verbatim}[frame=single]
d, err := f.Stat()
\end{Verbatim}

which looks as if it declares \texttt{d} and \texttt{err}. Notice,
though, that \texttt{err} appears in both statements. This duplication
is legal: \texttt{err} is declared by the first statement, but only
\emph{re-assigned} in the second. This means that the call to
\texttt{f.Stat} uses the existing \texttt{err} variable declared above,
and just gives it a new value.

In a \texttt{:=} declaration a variable \texttt{v} may appear even if it
has already been declared, provided:

\begin{itemize}
\item
  this declaration is in the same scope as the existing declaration of
  \texttt{v} (if \texttt{v} is already declared in an outer scope, the
  declaration will create a new variable),
\item
  the corresponding value in the initialization is assignable to
  \texttt{v}, and
\item
  there is at least one other variable in the declaration that is being
  declared anew.
\end{itemize}

This unusual property is pure pragmatism, making it easy to use a single
\texttt{err} value, for example, in a long \texttt{if-else} chain.
You'll see it used often.

\subsection*{For}

The Go \texttt{for} loop is similar to---but not the same as---C's. It
unifies \texttt{for} and \texttt{while} and there is no
\texttt{do-while}. There are three forms, only one of which has
semicolons.

\begin{Verbatim}[frame=single]
// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
\end{Verbatim}

Short declarations make it easy to declare the index variable right in
the loop.

\begin{Verbatim}[frame=single]
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
\end{Verbatim}

If you're looping over an array, slice, string, or map, or reading from
a channel, a \texttt{range} clause can manage the loop.

\begin{Verbatim}[frame=single]
for key, value := range oldMap {
    newMap[key] = value
}
\end{Verbatim}

If you only need the first item in the range (the key or index), drop
the second:

\begin{Verbatim}[frame=single]
for key := range m {
    if expired(key) {
        delete(m, key)
    }
}
\end{Verbatim}

If you only need the second item in the range (the value), use the
\emph{blank identifier}, an underscore, to discard the first:

\begin{Verbatim}[frame=single]
sum := 0
for _, value := range array {
    sum += value
}
\end{Verbatim}

For strings, the \texttt{range} does more work for you, breaking out
individual Unicode characters by parsing the UTF-8. Erroneous encodings
consume one byte and produce the replacement rune U+FFFD. The loop

\begin{Verbatim}[frame=single]
for pos, char := range "日本語" {
    fmt.Printf("character %c starts at byte position %d\n", char, pos)
}
\end{Verbatim}

prints

\begin{Verbatim}[frame=single]
character 日 starts at byte position 0
character 本 starts at byte position 3
character 語 starts at byte position 6
\end{Verbatim}

Finally, Go has no comma operator and \texttt{++} and \texttt{-{}-} are
statements not expressions. Thus if you want to run multiple variables
in a \texttt{for} you should use parallel assignment.

\begin{Verbatim}[frame=single]
// Reverse a
for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
\end{Verbatim}

\subsection*{Switch}

Go's \texttt{switch} is more general than C's. The expressions need not
be constants or even integers, the cases are evaluated top to bottom
until a match is found, and if the \texttt{switch} has no expression it
switches on \texttt{true}. It's therefore possible---and idiomatic---to
write an \texttt{if}-\texttt{else}-\texttt{if}-\texttt{else} chain as a
\texttt{switch}.

\begin{Verbatim}[frame=single]
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
\end{Verbatim}

There is no automatic fall through, but cases can be presented in
comma-separated lists.

\begin{Verbatim}[frame=single]
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+', '%':
        return true
    }
    return false
}
\end{Verbatim}

Here's a comparison routine for byte arrays that uses two
\texttt{switch} statements:

\begin{Verbatim}[frame=single]
// Compare returns an integer comparing the two byte arrays,
// lexicographically.
// The result will be 0 if a == b, -1 if a < b, and +1 if a > b
func Compare(a, b []byte) int {
    for i := 0; i < len(a) && i < len(b); i++ {
        switch {
        case a[i] > b[i]:
            return 1
        case a[i] < b[i]:
            return -1
        }
    }
    switch {
    case len(a) < len(b):
        return -1
    case len(a) > len(b):
        return 1
    }
    return 0
}
\end{Verbatim}

A switch can also be used to discover the dynamic type of an interface
variable. Such a \emph{type switch} uses the syntax of a type assertion
with the keyword \texttt{type} inside the parentheses. If the switch
declares a variable in the expression, the variable will have the
corresponding type in each clause.

\begin{Verbatim}[frame=single]
switch t := interfaceValue.(type) {
default:
    fmt.Printf("unexpected type %T", t)  // %T prints type
case bool:
    fmt.Printf("boolean %t\n", t)
case int:
    fmt.Printf("integer %d\n", t)
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t)
case *int:
    fmt.Printf("pointer to integer %d\n", *t)
}
\end{Verbatim}

\section*{Functions}

\subsection*{Multiple return values}

One of Go's unusual features is that functions and methods can return
multiple values. This form can be used to improve on a couple of clumsy
idioms in C programs: in-band error returns (such as \texttt{-1} for
\texttt{EOF}) and modifying an argument.

In C, a write error is signaled by a negative count with the error code
secreted away in a volatile location. In Go, \texttt{Write} can return a
count \emph{and} an error: ``Yes, you wrote some bytes but not all of
them because you filled the device''. The signature of
\texttt{File.Write} in package \texttt{os} is:

\begin{Verbatim}[frame=single]
func (file *File) Write(b []byte) (n int, err error)
\end{Verbatim}

and as the documentation says, it returns the number of bytes written
and a non-nil \texttt{error} when \texttt{n} \texttt{!=}
\texttt{len(b)}. This is a common style; see the section on error
handling for more examples.

A similar approach obviates the need to pass a pointer to a return value
to simulate a reference parameter. Here's a simple-minded function to
grab a number from a position in a byte array, returning the number and
the next position.

\begin{Verbatim}[frame=single]
func nextInt(b []byte, i int) (int, int) {
    for ; i < len(b) && !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i < len(b) && isDigit(b[i]); i++ {
        x = x*10 + int(b[i])-'0'
    }
    return x, i
}
\end{Verbatim}

You could use it to scan the numbers in an input array \texttt{a} like
this:

\begin{Verbatim}[frame=single]
    for i := 0; i < len(a); {
        x, i = nextInt(a, i)
        fmt.Println(x)
    }
\end{Verbatim}

\subsection*{Named result parameters}

The return or result ``parameters'' of a Go function can be given names
and used as regular variables, just like the incoming parameters. When
named, they are initialized to the zero values for their types when the
function begins; if the function executes a \texttt{return} statement
with no arguments, the current values of the result parameters are used
as the returned values.

The names are not mandatory but they can make code shorter and clearer:
they're documentation. If we name the results of \texttt{nextInt} it
becomes obvious which returned \texttt{int} is which.

\begin{Verbatim}[frame=single]
func nextInt(b []byte, pos int) (value, nextPos int) {
\end{Verbatim}

Because named results are initialized and tied to an unadorned return,
they can simplify as well as clarify. Here's a version of
\texttt{io.ReadFull} that uses them well:

\begin{Verbatim}[frame=single]
func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) > 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
\end{Verbatim}

\subsection*{Defer}

Go's \texttt{defer} statement schedules a function call (the
\emph{deferred} function) to be run immediately before the function
executing the \texttt{defer} returns. It's an unusual but effective way
to deal with situations such as resources that must be released
regardless of which path a function takes to return. The canonical
examples are unlocking a mutex or closing a file.

\begin{Verbatim}[frame=single]
// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
\end{Verbatim}

Deferring a call to a function such as \texttt{Close} has two
advantages. First, it guarantees that you will never forget to close the
file, a mistake that's easy to make if you later edit the function to
add a new return path. Second, it means that the close sits near the
open, which is much clearer than placing it at the end of the function.

The arguments to the deferred function (which include the receiver if
the function is a method) are evaluated when the \emph{defer} executes,
not when the \emph{call} executes. Besides avoiding worries about
variables changing values as the function executes, this means that a
single deferred call site can defer multiple function executions. Here's
a silly example.

\begin{Verbatim}[frame=single]
for i := 0; i < 5; i++ {
    defer fmt.Printf("%d ", i)
}
\end{Verbatim}

Deferred functions are executed in LIFO order, so this code will cause
\texttt{4 3 2 1 0} to be printed when the function returns. A more
plausible example is a simple way to trace function execution through
the program. We could write a couple of simple tracing routines like
this:

\begin{Verbatim}[frame=single]
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// Use them like this:
func a() {
    trace("a")
    defer untrace("a")
    // do something....
}
\end{Verbatim}

We can do better by exploiting the fact that arguments to deferred
functions are evaluated when the \texttt{defer} executes. The tracing
routine can set up the argument to the untracing routine. This example:

\begin{Verbatim}[frame=single]
func trace(s string) string {
    fmt.Println("entering:", s)
    return s
}

func un(s string) {
    fmt.Println("leaving:", s)
}

func a() {
    defer un(trace("a"))
    fmt.Println("in a")
}

func b() {
    defer un(trace("b"))
    fmt.Println("in b")
    a()
}

func main() {
    b()
}
\end{Verbatim}

prints

\begin{Verbatim}[frame=single]
entering: b
in b
entering: a
in a
leaving: a
leaving: b
\end{Verbatim}

For programmers accustomed to block-level resource management from other
languages, \texttt{defer} may seem peculiar, but its most interesting
and powerful applications come precisely from the fact that it's not
block-based but function-based. In the section on \texttt{panic} and
\texttt{recover} we'll see another example of its possibilities.

\section*{Data}

\subsection*{Allocation with \texttt{new}}

Go has two allocation primitives, the built-in functions \texttt{new}
and \texttt{make}. They do different things and apply to different
types, which can be confusing, but the rules are simple. Let's talk
about \texttt{new} first. It's a built-in function that allocates
memory, but unlike its namesakes in some other languages it does not
\emph{initialize} the memory, it only \emph{zeros} it. That is,
\texttt{new(T)} allocates zeroed storage for a new item of type
\texttt{T} and returns its address, a value of type \texttt{*T}. In Go
terminology, it returns a pointer to a newly allocated zero value of
type \texttt{T}.

Since the memory returned by \texttt{new} is zeroed, it's helpful to
arrange when designing your data structures that the zero value of each
type can be used without further initialization. This means a user of
the data structure can create one with \texttt{new} and get right to
work. For example, the documentation for \texttt{bytes.Buffer} states
that "the zero value for \texttt{Buffer} is an empty buffer ready to
use." Similarly, \texttt{sync.Mutex} does not have an explicit
constructor or \texttt{Init} method. Instead, the zero value for a
\texttt{sync.Mutex} is defined to be an unlocked mutex.

The zero-value-is-useful property works transitively. Consider this type
declaration.

\begin{Verbatim}[frame=single]
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
\end{Verbatim}

Values of type \texttt{SyncedBuffer} are also ready to use immediately
upon allocation or just declaration. In the next snippet, both
\texttt{p} and \texttt{v} will work correctly without further
arrangement.

\begin{Verbatim}[frame=single]
p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
\end{Verbatim}

\subsection*{Constructors and composite literals}

Sometimes the zero value isn't good enough and an initializing
constructor is necessary, as in this example derived from package
\texttt{os}.

\begin{Verbatim}[frame=single]
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
\end{Verbatim}

There's a lot of boiler plate in there. We can simplify it using a
\emph{composite literal}, which is an expression that creates a new
instance each time it is evaluated.

\begin{Verbatim}[frame=single]
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &f
}
\end{Verbatim}

Note that, unlike in C, it's perfectly OK to return the address of a
local variable; the storage associated with the variable survives after
the function returns. In fact, taking the address of a composite literal
allocates a fresh instance each time it is evaluated, so we can combine
these last two lines.

\begin{Verbatim}[frame=single]
    return &File{fd, name, nil, 0}
\end{Verbatim}

The fields of a composite literal are laid out in order and must all be
present. However, by labeling the elements explicitly as
\emph{field}\texttt{:}\emph{value} pairs, the initializers can appear in
any order, with the missing ones left as their respective zero values.
Thus we could say

\begin{Verbatim}[frame=single]
    return &File{fd: fd, name: name}
\end{Verbatim}

As a limiting case, if a composite literal contains no fields at all, it
creates a zero value for the type. The expressions \texttt{new(File)}
and \texttt{\&File\{\}} are equivalent.

Composite literals can also be created for arrays, slices, and maps,
with the field labels being indices or map keys as appropriate. In these
examples, the initializations work regardless of the values of
\texttt{Enone}, \texttt{Eio}, and \texttt{Einval}, as long as they are
distinct.

\begin{Verbatim}[frame=single]
a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
\end{Verbatim}

\subsection*{Allocation with \texttt{make}}

Back to allocation. The built-in function
\texttt{make(T, }\emph{args}\texttt{)} serves a purpose different from
\texttt{new(T)}. It creates slices, maps, and channels only, and it
returns an \emph{initialized} (not \emph{zeroed}) value of type
\texttt{T} (not \texttt{*T}). The reason for the distinction is that
these three types are, under the covers, references to data structures
that must be initialized before use. A slice, for example, is a
three-item descriptor containing a pointer to the data (inside an
array), the length, and the capacity, and until those items are
initialized, the slice is \texttt{nil}. For slices, maps, and channels,
\texttt{make} initializes the internal data structure and prepares the
value for use. For instance,

\begin{Verbatim}[frame=single]
make([]int, 10, 100)
\end{Verbatim}

allocates an array of 100 ints and then creates a slice structure with
length 10 and a capacity of 100 pointing at the first 10 elements of the
array. (When making a slice, the capacity can be omitted; see the
section on slices for more information.) In contrast,
\texttt{new({[}{]}int)} returns a pointer to a newly allocated, zeroed
slice structure, that is, a pointer to a \texttt{nil} slice value.

These examples illustrate the difference between \texttt{new} and
\texttt{make}.

\begin{Verbatim}[frame=single]
var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
\end{Verbatim}

Remember that \texttt{make} applies only to maps, slices and channels
and does not return a pointer. To obtain an explicit pointer allocate
with \texttt{new}.

\subsection*{Arrays}

Arrays are useful when planning the detailed layout of memory and
sometimes can help avoid allocation, but primarily they are a building
block for slices, the subject of the next section. To lay the foundation
for that topic, here are a few words about arrays.

There are major differences between the ways arrays work in Go and C. In
Go,

\begin{itemize}
\item
  Arrays are values. Assigning one array to another copies all the
  elements.
\item
  In particular, if you pass an array to a function, it will receive a
  \emph{copy} of the array, not a pointer to it.
\item
  The size of an array is part of its type. The types
  \texttt{{[}10{]}int} and \texttt{{[}20{]}int} are distinct.
\end{itemize}

The value property can be useful but also expensive; if you want C-like
behavior and efficiency, you can pass a pointer to the array.

\begin{Verbatim}[frame=single]
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // Note the explicit address-of operator
\end{Verbatim}

But even this style isn't idiomatic Go. Slices are.

\subsection*{Slices}

Slices wrap arrays to give a more general, powerful, and convenient
interface to sequences of data. Except for items with explicit dimension
such as transformation matrices, most array programming in Go is done
with slices rather than simple arrays.

Slices are \emph{reference types}, which means that if you assign one
slice to another, both refer to the same underlying array. For instance,
if a function takes a slice argument, changes it makes to the elements
of the slice will be visible to the caller, analogous to passing a
pointer to the underlying array. A \texttt{Read} function can therefore
accept a slice argument rather than a pointer and a count; the length
within the slice sets an upper limit of how much data to read. Here is
the signature of the \texttt{Read} method of the \texttt{File} type in
package \texttt{os}:

\begin{Verbatim}[frame=single]
func (file *File) Read(buf []byte) (n int, err error)
\end{Verbatim}

The method returns the number of bytes read and an error value, if any.
To read into the first 32 bytes of a larger buffer \texttt{b},
\emph{slice} (here used as a verb) the buffer.

\begin{Verbatim}[frame=single]
    n, err := f.Read(buf[0:32])
\end{Verbatim}

Such slicing is common and efficient. In fact, leaving efficiency aside
for the moment, the following snippet would also read the first 32 bytes
of the buffer.

\begin{Verbatim}[frame=single]
    var n int
    var err error
    for i := 0; i < 32; i++ {
        nbytes, e := f.Read(buf[i:i+1])  // Read one byte.
        if nbytes == 0 || e != nil {
            err = e
            break
        }
        n += nbytes
    }
\end{Verbatim}

The length of a slice may be changed as long as it still fits within the
limits of the underlying array; just assign it to a slice of itself. The
\emph{capacity} of a slice, accessible by the built-in function
\texttt{cap}, reports the maximum length the slice may assume. Here is a
function to append data to a slice. If the data exceeds the capacity,
the slice is reallocated. The resulting slice is returned. The function
uses the fact that \texttt{len} and \texttt{cap} are legal when applied
to the \texttt{nil} slice, and return 0.

\begin{Verbatim}[frame=single]
func Append(slice, data[]byte) []byte {
    l := len(slice)
    if l + len(data) > cap(slice) {  // reallocate
        // Allocate double what's needed, for future growth.
        newSlice := make([]byte, (l+len(data))*2)
        // The copy function is predeclared and works for any slice type.
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    for i, c := range data {
        slice[l+i] = c
    }
    return slice
}
\end{Verbatim}

We must return the slice afterwards because, although \texttt{Append}
can modify the elements of \texttt{slice}, the slice itself (the
run-time data structure holding the pointer, length, and capacity) is
passed by value.

The idea of appending to a slice is so useful it's captured by the
\texttt{append} built-in function. To understand that function's design,
though, we need a little more information, so we'll return to it later.

\hyperdef{}{maps}{\subsection*{Maps}\label{maps}}

Maps are a convenient and powerful built-in data structure to associate
values of different types. The key can be of any type for which the
equality operator is defined, such as integers, floating point and
complex numbers, strings, pointers, interfaces (as long as the dynamic
type supports equality), structs and arrays. Slices cannot be used as
map keys, because equality is not defined on them. Like slices, maps are
a reference type. If you pass a map to a function that changes the
contents of the map, the changes will be visible in the caller.

Maps can be constructed using the usual composite literal syntax with
colon-separated key-value pairs, so it's easy to build them during
initialization.

\begin{Verbatim}[frame=single]
var timeZone = map[string] int {
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
\end{Verbatim}

Assigning and fetching map values looks syntactically just like doing
the same for arrays except that the index doesn't need to be an integer.

\begin{Verbatim}[frame=single]
offset := timeZone["EST"]
\end{Verbatim}

An attempt to fetch a map value with a key that is not present in the
map will return the zero value for the type of the entries in the map.
For instance, if the map contains integers, looking up a non-existent
key will return \texttt{0}. A set can be implemented as a map with value
type \texttt{bool}. Set the map entry to \texttt{true} to put the value
in the set, and then test it by simple indexing.

\begin{Verbatim}[frame=single]
attended := map[string] bool {
    "Ann": true,
    "Joe": true,
    ...
}

if attended[person] { // will be false if person is not in the map
    fmt.Println(person, "was at the meeting")
}
\end{Verbatim}

Sometimes you need to distinguish a missing entry from a zero value. Is
there an entry for \texttt{"UTC"} or is that zero value because it's not
in the map at all? You can discriminate with a form of multiple
assignment.

\begin{Verbatim}[frame=single]
var seconds int
var ok bool
seconds, ok = timeZone[tz]
\end{Verbatim}

For obvious reasons this is called the ``comma ok'' idiom. In this
example, if \texttt{tz} is present, \texttt{seconds} will be set
appropriately and \texttt{ok} will be true; if not, \texttt{seconds}
will be set to zero and \texttt{ok} will be false. Here's a function
that puts it together with a nice error report:

\begin{Verbatim}[frame=single]
func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("unknown time zone:", tz)
    return 0
}
\end{Verbatim}

To test for presence in the map without worrying about the actual value,
you can use the blank identifier (\texttt{\_}). The blank identifier can
be assigned or declared with any value of any type, with the value
discarded harmlessly. For testing just presence in a map, use the blank
identifier in place of the usual variable for the value.

\begin{Verbatim}[frame=single]
_, present := timeZone[tz]
\end{Verbatim}

To delete a map entry, use the \texttt{delete} built-in function, whose
arguments are the map and the key to be deleted. It's safe to do this
this even if the key is already absent from the map.

\begin{Verbatim}[frame=single]
delete(timeZone, "PDT")  // Now on Standard Time
\end{Verbatim}

\subsection*{Printing}

Formatted printing in Go uses a style similar to C's \texttt{printf}
family but is richer and more general. The functions live in the
\texttt{fmt} package and have capitalized names: \texttt{fmt.Printf},
\texttt{fmt.Fprintf}, \texttt{fmt.Sprintf} and so on. The string
functions (\texttt{Sprintf} etc.) return a string rather than filling in
a provided buffer.

You don't need to provide a format string. For each of \texttt{Printf},
\texttt{Fprintf} and \texttt{Sprintf} there is another pair of
functions, for instance \texttt{Print} and \texttt{Println}. These
functions do not take a format string but instead generate a default
format for each argument. The \texttt{Println} versions also insert a
blank between arguments and append a newline to the output while the
\texttt{Print} versions add blanks only if the operand on neither side
is a string. In this example each line produces the same output.

\begin{Verbatim}[frame=single]
fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
\end{Verbatim}

As mentioned in the \href{http://tour.golang.org}{Tour},
\texttt{fmt.Fprint} and friends take as a first argument any object that
implements the \texttt{io.Writer} interface; the variables
\texttt{os.Stdout} and \texttt{os.Stderr} are familiar instances.

Here things start to diverge from C. First, the numeric formats such as
\texttt{\%d} do not take flags for signedness or size; instead, the
printing routines use the type of the argument to decide these
properties.

\begin{Verbatim}[frame=single]
var x uint64 = 1<<64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
\end{Verbatim}

prints

\begin{Verbatim}[frame=single]
18446744073709551615 ffffffffffffffff; -1 -1
\end{Verbatim}

If you just want the default conversion, such as decimal for integers,
you can use the catchall format \texttt{\%v} (for ``value''); the result
is exactly what \texttt{Print} and \texttt{Println} would produce.
Moreover, that format can print \emph{any} value, even arrays, structs,
and maps. Here is a print statement for the time zone map defined in the
previous section.

\begin{Verbatim}[frame=single]
fmt.Printf("%v\n", timeZone)  // or just fmt.Println(timeZone)
\end{Verbatim}

which gives output

\begin{Verbatim}[frame=single]
map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]
\end{Verbatim}

For maps the keys may be output in any order, of course. When printing a
struct, the modified format \texttt{\%+v} annotates the fields of the
structure with their names, and for any value the alternate format
\texttt{\%\#v} prints the value in full Go syntax.

\begin{Verbatim}[frame=single]
type T struct {
    a int
    b float64
    c string
}
t := &T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
\end{Verbatim}

prints

\begin{Verbatim}[frame=single]
&{7 -2.35 abc   def}
&{a:7 b:-2.35 c:abc     def}
&main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string] int{"CST":-21600, "PST":-28800, "EST":-18000, "UTC":0, "MST":-25200}
\end{Verbatim}

(Note the ampersands.) That quoted string format is also available
through \texttt{\%q} when applied to a value of type \texttt{string} or
\texttt{{[}{]}byte}; the alternate format \texttt{\%\#q} will use
backquotes instead if possible. Also, \texttt{\%x} works on strings and
arrays of bytes as well as on integers, generating a long hexadecimal
string, and with a space in the format (\texttt{\%~x}) it puts spaces
between the bytes.

Another handy format is \texttt{\%T}, which prints the \emph{type} of a
value.

\begin{Verbatim}[frame=single]
fmt.Printf("%T\n", timeZone)
\end{Verbatim}

prints

\begin{Verbatim}[frame=single]
map[string] int
\end{Verbatim}

If you want to control the default format for a custom type, all that's
required is to define a method with the signature
\texttt{String() string} on the type. For our simple type \texttt{T},
that might look like this.

\begin{Verbatim}[frame=single]
func (t *T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
\end{Verbatim}

to print in the format

\begin{Verbatim}[frame=single]
7/-2.35/"abc\tdef"
\end{Verbatim}

(If you need to print \emph{values} of type \texttt{T} as well as
pointers to \texttt{T}, the receiver for \texttt{String} must be of
value type; this example used a pointer because that's more efficient
and idiomatic for struct types. See the section below on
pointers vs. value receivers for more information.)

Our \texttt{String} method is able to call \texttt{Sprintf} because the
print routines are fully reentrant and can be used recursively. We can
even go one step further and pass a print routine's arguments directly
to another such routine. The signature of \texttt{Printf} uses the type
\texttt{...interface\{\}} for its final argument to specify that an
arbitrary number of parameters (of arbitrary type) can appear after the
format.

\begin{Verbatim}[frame=single]
func Printf(format string, v ...interface{}) (n int, err error) {
\end{Verbatim}

Within the function \texttt{Printf}, \texttt{v} acts like a variable of
type \texttt{{[}{]}interface\{\}} but if it is passed to another
variadic function, it acts like a regular list of arguments. Here is the
implementation of the function \texttt{log.Println} we used above. It
passes its arguments directly to \texttt{fmt.Sprintln} for the actual
formatting.

\begin{Verbatim}[frame=single]
// Println prints to the standard logger in the manner of fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)
}
\end{Verbatim}

We write \texttt{...} after \texttt{v} in the nested call to
\texttt{Sprintln} to tell the compiler to treat \texttt{v} as a list of
arguments; otherwise it would just pass \texttt{v} as a single slice
argument.

There's even more to printing than we've covered here. See the
\texttt{godoc} documentation for package \texttt{fmt} for the details.

By the way, a \texttt{...} parameter can be of a specific type, for
instance \texttt{...int} for a min function that chooses the least of a
list of integers:

\begin{Verbatim}[frame=single]
func Min(a ...int) int {
    min := int(^uint(0) >> 1)  // largest int
    for _, i := range a {
        if i < min {
            min = i
        }
    }
    return min
}
\end{Verbatim}

\subsection*{Append}

Now we have the missing piece we needed to explain the design of the
\texttt{append} built-in function. The signature of \texttt{append} is
different from our custom \texttt{Append} function above. Schematically,
it's like this:

\begin{Verbatim}[frame=single]
func append(slice []T, elements...T) []T
\end{Verbatim}

where \emph{T} is a placeholder for any given type. You can't actually
write a function in Go where the type \texttt{T} is determined by the
caller. That's why \texttt{append} is built in: it needs support from
the compiler.

What \texttt{append} does is append the elements to the end of the slice
and return the result. The result needs to be returned because, as with
our hand-written \texttt{Append}, the underlying array may change. This
simple example

\begin{Verbatim}[frame=single]
x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
\end{Verbatim}

prints \texttt{{[}1 2 3 4 5 6{]}}. So \texttt{append} works a little
like \texttt{Printf}, collecting an arbitrary number of arguments.

But what if we wanted to do what our \texttt{Append} does and append a
slice to a slice? Easy: use \texttt{...} at the call site, just as we
did in the call to \texttt{Output} above. This snippet produces
identical output to the one above.

\begin{Verbatim}[frame=single]
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
\end{Verbatim}

Without that \texttt{...}, it wouldn't compile because the types would
be wrong; \texttt{y} is not of type \texttt{int}.

\section*{Initialization}

Although it doesn't look superficially very different from
initialization in C or C++, initialization in Go is more powerful.
Complex structures can be built during initialization and the ordering
issues between initialized objects in different packages are handled
correctly.

\subsection*{Constants}

Constants in Go are just that---constant. They are created at compile
time, even when defined as locals in functions, and can only be numbers,
strings or booleans. Because of the compile-time restriction, the
expressions that define them must be constant expressions, evaluatable
by the compiler. For instance, \texttt{1\textless{}\textless{}3} is a
constant expression, while \texttt{math.Sin(math.Pi/4)} is not because
the function call to \texttt{math.Sin} needs to happen at run time.

In Go, enumerated constants are created using the \texttt{iota}
enumerator. Since \texttt{iota} can be part of an expression and
expressions can be implicitly repeated, it is easy to build intricate
sets of values.

\{\{code ``/doc/progs/eff\_bytesize.go'' `/\^{}type ByteSize/`
`/\^{}\textbackslash{})/`\}\}

The ability to attach a method such as \texttt{String} to a type makes
it possible for such values to format themselves automatically for
printing, even as part of a general type.

\{\{code ``/doc/progs/eff\_bytesize.go'' `/\^{}func.*ByteSize.*String/`
`/\^{}\}/`\}\}

The expression \texttt{YB} prints as \texttt{1.00YB}, while
\texttt{ByteSize(1e13)} prints as \texttt{9.09TB}.

Note that it's fine to call \texttt{Sprintf} and friends in the
implementation of \texttt{String} methods, but beware of recurring into
the \texttt{String} method through the nested \texttt{Sprintf} call
using a string format (\texttt{\%s}, \texttt{\%q}, \texttt{\%v},
\texttt{\%x} or \texttt{\%X}). The \texttt{ByteSize} implementation of
\texttt{String} is safe because it calls \texttt{Sprintf} with
\texttt{\%f}.

\subsection*{Variables}

Variables can be initialized just like constants but the initializer can
be a general expression computed at run time.

\begin{Verbatim}[frame=single]
var (
    HOME = os.Getenv("HOME")
    USER = os.Getenv("USER")
    GOROOT = os.Getenv("GOROOT")
)
\end{Verbatim}

\subsection*{The init function}

Finally, each source file can define its own niladic \texttt{init}
function to set up whatever state is required. (Actually each file can
have multiple \texttt{init} functions.) And finally means finally:
\texttt{init} is called after all the variable declarations in the
package have evaluated their initializers, and those are evaluated only
after all the imported packages have been initialized.

Besides initializations that cannot be expressed as declarations, a
common use of \texttt{init} functions is to verify or repair correctness
of the program state before real execution begins.

\begin{Verbatim}[frame=single]
func init() {
    if USER == "" {
        log.Fatal("$USER not set")
    }
    if HOME == "" {
        HOME = "/usr/" + USER
    }
    if GOROOT == "" {
        GOROOT = HOME + "/go"
    }
    // GOROOT may be overridden by --goroot flag on command line.
    flag.StringVar(&GOROOT, "goroot", GOROOT, "Go root directory")
}
\end{Verbatim}

\section*{Methods}

\subsection*{Pointers vs. Values}

Methods can be defined for any named type that is not a pointer or an
interface; the receiver does not have to be a struct.

In the discussion of slices above, we wrote an \texttt{Append} function.
We can define it as a method on slices instead. To do this, we first
declare a named type to which we can bind the method, and then make the
receiver for the method a value of that type.

\begin{Verbatim}[frame=single]
type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // Body exactly the same as above
}
\end{Verbatim}

This still requires the method to return the updated slice. We can
eliminate that clumsiness by redefining the method to take a
\emph{pointer} to a \texttt{ByteSlice} as its receiver, so the method
can overwrite the caller's slice.

\begin{Verbatim}[frame=single]
func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // Body as above, without the return.
    *p = slice
}
\end{Verbatim}

In fact, we can do even better. If we modify our function so it looks
like a standard \texttt{Write} method, like this,

\begin{Verbatim}[frame=single]
func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // Again as above.
    *p = slice
    return len(data), nil
}
\end{Verbatim}

then the type \texttt{*ByteSlice} satisfies the standard interface
\texttt{io.Writer}, which is handy. For instance, we can print into one.

\begin{Verbatim}[frame=single]
    var b ByteSlice
    fmt.Fprintf(&b, "This hour has %d days\n", 7)
\end{Verbatim}

We pass the address of a \texttt{ByteSlice} because only
\texttt{*ByteSlice} satisfies \texttt{io.Writer}. The rule about
pointers vs. values for receivers is that value methods can be invoked
on pointers and values, but pointer methods can only be invoked on
pointers. This is because pointer methods can modify the receiver;
invoking them on a copy of the value would cause those modifications to
be discarded.

By the way, the idea of using \texttt{Write} on a slice of bytes is
implemented by \texttt{bytes.Buffer}.

\section*{Interfaces and other types}

\subsection*{Interfaces}

Interfaces in Go provide a way to specify the behavior of an object: if
something can do \emph{this}, then it can be used \emph{here}. We've
seen a couple of simple examples already; custom printers can be
implemented by a \texttt{String} method while \texttt{Fprintf} can
generate output to anything with a \texttt{Write} method. Interfaces
with only one or two methods are common in Go code, and are usually
given a name derived from the method, such as \texttt{io.Writer} for
something that implements \texttt{Write}.

A type can implement multiple interfaces. For instance, a collection can
be sorted by the routines in package \texttt{sort} if it implements
\texttt{sort.Interface}, which contains \texttt{Len()},
\texttt{Less(i, j int) bool}, and \texttt{Swap(i, j int)}, and it could
also have a custom formatter. In this contrived example
\texttt{Sequence} satisfies both.

\{\{code ``/doc/progs/eff\_sequence.go'' `/\^{}type/` ``\$''\}\}

\subsection*{Conversions}

The \texttt{String} method of \texttt{Sequence} is recreating the work
that \texttt{Sprint} already does for slices. We can share the effort if
we convert the \texttt{Sequence} to a plain \texttt{{[}{]}int} before
calling \texttt{Sprint}.

\begin{Verbatim}[frame=single]
func (s Sequence) String() string {
    sort.Sort(s)
    return fmt.Sprint([]int(s))
}
\end{Verbatim}

The conversion causes \texttt{s} to be treated as an ordinary slice and
therefore receive the default formatting. Without the conversion,
\texttt{Sprint} would find the \texttt{String} method of
\texttt{Sequence} and recur indefinitely. Because the two types
(\texttt{Sequence} and \texttt{{[}{]}int}) are the same if we ignore the
type name, it's legal to convert between them. The conversion doesn't
create a new value, it just temporarily acts as though the existing
value has a new type. (There are other legal conversions, such as from
integer to floating point, that do create a new value.)

It's an idiom in Go programs to convert the type of an expression to
access a different set of methods. As an example, we could use the
existing type \texttt{sort.IntSlice} to reduce the entire example to
this:

\begin{Verbatim}[frame=single]
type Sequence []int

// Method for printing - sorts the elements before printing
func (s Sequence) String() string {
    sort.IntSlice(s).Sort()
    return fmt.Sprint([]int(s))
}
\end{Verbatim}

Now, instead of having \texttt{Sequence} implement multiple interfaces
(sorting and printing), we're using the ability of a data item to be
converted to multiple types (\texttt{Sequence}, \texttt{sort.IntSlice}
and \texttt{{[}{]}int}), each of which does some part of the job. That's
more unusual in practice but can be effective.

\subsection*{Generality}

If a type exists only to implement an interface and has no exported
methods beyond that interface, there is no need to export the type
itself. Exporting just the interface makes it clear that it's the
behavior that matters, not the implementation, and that other
implementations with different properties can mirror the behavior of the
original type. It also avoids the need to repeat the documentation on
every instance of a common method.

In such cases, the constructor should return an interface value rather
than the implementing type. As an example, in the hash libraries both
\texttt{crc32.NewIEEE} and \texttt{adler32.New} return the interface
type \texttt{hash.Hash32}. Substituting the CRC-32 algorithm for
Adler-32 in a Go program requires only changing the constructor call;
the rest of the code is unaffected by the change of algorithm.

A similar approach allows the streaming cipher algorithms in the various
\texttt{crypto} packages to be separated from the block ciphers they
chain together. The \texttt{Block} interface in the
\texttt{crypto/cipher} package specifies the behavior of a block cipher,
which provides encryption of a single block of data. Then, by analogy
with the \texttt{bufio} package, cipher packages that implement this
interface can be used to construct streaming ciphers, represented by the
\texttt{Stream} interface, without knowing the details of the block
encryption.

The \texttt{crypto/cipher} interfaces look like this:

\begin{Verbatim}[frame=single]
type Block interface {
    BlockSize() int
    Encrypt(src, dst []byte)
    Decrypt(src, dst []byte)
}

type Stream interface {
    XORKeyStream(dst, src []byte)
}
\end{Verbatim}

Here's the definition of the counter mode (CTR) stream, which turns a
block cipher into a streaming cipher; notice that the block cipher's
details are abstracted away:

\begin{Verbatim}[frame=single]
// NewCTR returns a Stream that encrypts/decrypts using the given Block in
// counter mode. The length of iv must be the same as the Block's block size.
func NewCTR(block Block, iv []byte) Stream
\end{Verbatim}

\texttt{NewCTR} applies not just to one specific encryption algorithm
and data source but to any implementation of the \texttt{Block}
interface and any \texttt{Stream}. Because they return interface values,
replacing CTR encryption with other encryption modes is a localized
change. The constructor calls must be edited, but because the
surrounding code must treat the result only as a \texttt{Stream}, it
won't notice the difference.

\subsection*{Interfaces and methods}

Since almost anything can have methods attached, almost anything can
satisfy an interface. One illustrative example is in the \texttt{http}
package, which defines the \texttt{Handler} interface. Any object that
implements \texttt{Handler} can serve HTTP requests.

\begin{Verbatim}[frame=single]
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
\end{Verbatim}

\texttt{ResponseWriter} is itself an interface that provides access to
the methods needed to return the response to the client. Those methods
include the standard \texttt{Write} method, so an
\texttt{http.ResponseWriter} can be used wherever an \texttt{io.Writer}
can be used. \texttt{Request} is a struct containing a parsed
representation of the request from the client.

For brevity, let's ignore POSTs and assume HTTP requests are always
GETs; that simplification does not affect the way the handlers are set
up. Here's a trivial but complete implementation of a handler to count
the number of times the page is visited.

\begin{Verbatim}[frame=single]
// Simple counter server.
type Counter struct {
    n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ctr.n++
    fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
\end{Verbatim}

(Keeping with our theme, note how \texttt{Fprintf} can print to an
\texttt{http.ResponseWriter}.) For reference, here's how to attach such
a server to a node on the URL tree.

\begin{Verbatim}[frame=single]
import "net/http"
...
ctr := new(Counter)
http.Handle("/counter", ctr)
\end{Verbatim}

But why make \texttt{Counter} a struct? An integer is all that's needed.
(The receiver needs to be a pointer so the increment is visible to the
caller.)

\begin{Verbatim}[frame=single]
// Simpler counter server.
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    *ctr++
    fmt.Fprintf(w, "counter = %d\n", *ctr)
}
\end{Verbatim}

What if your program has some internal state that needs to be notified
that a page has been visited? Tie a channel to the web page.

\begin{Verbatim}[frame=single]
// A channel that sends a notification on each visit.
// (Probably want the channel to be buffered.)
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ch <- req
    fmt.Fprint(w, "notification sent")
}
\end{Verbatim}

Finally, let's say we wanted to present on \texttt{/args} the arguments
used when invoking the server binary. It's easy to write a function to
print the arguments.

\begin{Verbatim}[frame=single]
func ArgServer() {
    for _, s := range os.Args {
        fmt.Println(s)
    }
}
\end{Verbatim}

How do we turn that into an HTTP server? We could make
\texttt{ArgServer} a method of some type whose value we ignore, but
there's a cleaner way. Since we can define a method for any type except
pointers and interfaces, we can write a method for a function. The
\texttt{http} package contains this code:

\begin{Verbatim}[frame=single]
// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers.  If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler object that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(c, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
    f(w, req)
}
\end{Verbatim}

\texttt{HandlerFunc} is a type with a method, \texttt{ServeHTTP}, so
values of that type can serve HTTP requests. Look at the implementation
of the method: the receiver is a function, \texttt{f}, and the method
calls \texttt{f}. That may seem odd but it's not that different from,
say, the receiver being a channel and the method sending on the channel.

To make \texttt{ArgServer} into an HTTP server, we first modify it to
have the right signature.

\begin{Verbatim}[frame=single]
// Argument server.
func ArgServer(w http.ResponseWriter, req *http.Request) {
    for _, s := range os.Args {
        fmt.Fprintln(w, s)
    }
}
\end{Verbatim}

\texttt{ArgServer} now has same signature as \texttt{HandlerFunc}, so it
can be converted to that type to access its methods, just as we
converted \texttt{Sequence} to \texttt{IntSlice} to access
\texttt{IntSlice.Sort}. The code to set it up is concise:

\begin{Verbatim}[frame=single]
http.Handle("/args", http.HandlerFunc(ArgServer))
\end{Verbatim}

When someone visits the page \texttt{/args}, the handler installed at
that page has value \texttt{ArgServer} and type \texttt{HandlerFunc}.
The HTTP server will invoke the method \texttt{ServeHTTP} of that type,
with \texttt{ArgServer} as the receiver, which will in turn call
\texttt{ArgServer} (via the invocation \texttt{f(c, req)} inside
\texttt{HandlerFunc.ServeHTTP}). The arguments will then be displayed.

In this section we have made an HTTP server from a struct, an integer, a
channel, and a function, all because interfaces are just sets of
methods, which can be defined for (almost) any type.

\section*{Embedding}

Go does not provide the typical, type-driven notion of subclassing, but
it does have the ability to ``borrow'' pieces of an implementation by
\emph{embedding} types within a struct or interface.

Interface embedding is very simple. We've mentioned the
\texttt{io.Reader} and \texttt{io.Writer} interfaces before; here are
their definitions.

\begin{Verbatim}[frame=single]
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
\end{Verbatim}

The \texttt{io} package also exports several other interfaces that
specify objects that can implement several such methods. For instance,
there is \texttt{io.ReadWriter}, an interface containing both
\texttt{Read} and \texttt{Write}. We could specify
\texttt{io.ReadWriter} by listing the two methods explicitly, but it's
easier and more evocative to embed the two interfaces to form the new
one, like this:

\begin{Verbatim}[frame=single]
// ReadWriter is the interface that combines the Reader and Writer interfaces.
type ReadWriter interface {
    Reader
    Writer
}
\end{Verbatim}

This says just what it looks like: A \texttt{ReadWriter} can do what a
\texttt{Reader} does \emph{and} what a \texttt{Writer} does; it is a
union of the embedded interfaces (which must be disjoint sets of
methods). Only interfaces can be embedded within interfaces.

The same basic idea applies to structs, but with more far-reaching
implications. The \texttt{bufio} package has two struct types,
\texttt{bufio.Reader} and \texttt{bufio.Writer}, each of which of course
implements the analogous interfaces from package \texttt{io}. And
\texttt{bufio} also implements a buffered reader/writer, which it does
by combining a reader and a writer into one struct using embedding: it
lists the types within the struct but does not give them field names.

\begin{Verbatim}[frame=single]
// ReadWriter stores pointers to a Reader and a Writer.
// It implements io.ReadWriter.
type ReadWriter struct {
    *Reader  // *bufio.Reader
    *Writer  // *bufio.Writer
}
\end{Verbatim}

The embedded elements are pointers to structs and of course must be
initialized to point to valid structs before they can be used. The
\texttt{ReadWriter} struct could be written as

\begin{Verbatim}[frame=single]
type ReadWriter struct {
    reader *Reader
    writer *Writer
}
\end{Verbatim}

but then to promote the methods of the fields and to satisfy the
\texttt{io} interfaces, we would also need to provide forwarding
methods, like this:

\begin{Verbatim}[frame=single]
func (rw *ReadWriter) Read(p []byte) (n int, err error) {
    return rw.reader.Read(p)
}
\end{Verbatim}

By embedding the structs directly, we avoid this bookkeeping. The
methods of embedded types come along for free, which means that
\texttt{bufio.ReadWriter} not only has the methods of
\texttt{bufio.Reader} and \texttt{bufio.Writer}, it also satisfies all
three interfaces: \texttt{io.Reader}, \texttt{io.Writer}, and
\texttt{io.ReadWriter}.

There's an important way in which embedding differs from subclassing.
When we embed a type, the methods of that type become methods of the
outer type, but when they are invoked the receiver of the method is the
inner type, not the outer one. In our example, when the \texttt{Read}
method of a \texttt{bufio.ReadWriter} is invoked, it has exactly the
same effect as the forwarding method written out above; the receiver is
the \texttt{reader} field of the \texttt{ReadWriter}, not the
\texttt{ReadWriter} itself.

Embedding can also be a simple convenience. This example shows an
embedded field alongside a regular, named field.

\begin{Verbatim}[frame=single]
type Job struct {
    Command string
    *log.Logger
}
\end{Verbatim}

The \texttt{Job} type now has the \texttt{Log}, \texttt{Logf} and other
methods of \texttt{*log.Logger}. We could have given the \texttt{Logger}
a field name, of course, but it's not necessary to do so. And now, once
initialized, we can log to the \texttt{Job}:

\begin{Verbatim}[frame=single]
job.Log("starting now...")
\end{Verbatim}

The \texttt{Logger} is a regular field of the struct and we can
initialize it in the usual way with a constructor,

\begin{Verbatim}[frame=single]
func NewJob(command string, logger *log.Logger) *Job {
    return &Job{command, logger}
}
\end{Verbatim}

or with a composite literal,

\begin{Verbatim}[frame=single]
job := &Job{command, log.New(os.Stderr, "Job: ", log.Ldate)}
\end{Verbatim}

If we need to refer to an embedded field directly, the type name of the
field, ignoring the package qualifier, serves as a field name. If we
needed to access the \texttt{*log.Logger} of a \texttt{Job} variable
\texttt{job}, we would write \texttt{job.Logger}. This would be useful
if we wanted to refine the methods of \texttt{Logger}.

\begin{Verbatim}[frame=single]
func (job *Job) Logf(format string, args ...interface{}) {
    job.Logger.Logf("%q: %s", job.Command, fmt.Sprintf(format, args...))
}
\end{Verbatim}

Embedding types introduces the problem of name conflicts but the rules
to resolve them are simple. First, a field or method \texttt{X} hides
any other item \texttt{X} in a more deeply nested part of the type. If
\texttt{log.Logger} contained a field or method called \texttt{Command},
the \texttt{Command} field of \texttt{Job} would dominate it.

Second, if the same name appears at the same nesting level, it is
usually an error; it would be erroneous to embed \texttt{log.Logger} if
the \texttt{Job} struct contained another field or method called
\texttt{Logger}. However, if the duplicate name is never mentioned in
the program outside the type definition, it is OK. This qualification
provides some protection against changes made to types embedded from
outside; there is no problem if a field is added that conflicts with
another field in another subtype if neither field is ever used.

\section*{Concurrency}

\subsection*{Share by communicating}

Concurrent programming is a large topic and there is space only for some
Go-specific highlights here.

Concurrent programming in many environments is made difficult by the
subtleties required to implement correct access to shared variables. Go
encourages a different approach in which shared values are passed around
on channels and, in fact, never actively shared by separate threads of
execution. Only one goroutine has access to the value at any given time.
Data races cannot occur, by design. To encourage this way of thinking we
have reduced it to a slogan:

\begin{quote}
Do not communicate by sharing memory; instead, share memory by
communicating.
\end{quote}

This approach can be taken too far. Reference counts may be best done by
putting a mutex around an integer variable, for instance. But as a
high-level approach, using channels to control access makes it easier to
write clear, correct programs.

One way to think about this model is to consider a typical
single-threaded program running on one CPU. It has no need for
synchronization primitives. Now run another such instance; it too needs
no synchronization. Now let those two communicate; if the communication
is the synchronizer, there's still no need for other synchronization.
Unix pipelines, for example, fit this model perfectly. Although Go's
approach to concurrency originates in Hoare's Communicating Sequential
Processes (CSP), it can also be seen as a type-safe generalization of
Unix pipes.

\subsection*{Goroutines}

They're called \emph{goroutines} because the existing terms---threads,
coroutines, processes, and so on---convey inaccurate connotations. A
goroutine has a simple model: it is a function executing concurrently
with other goroutines in the same address space. It is lightweight,
costing little more than the allocation of stack space. And the stacks
start small, so they are cheap, and grow by allocating (and freeing)
heap storage as required.

Goroutines are multiplexed onto multiple OS threads so if one should
block, such as while waiting for I/O, others continue to run. Their
design hides many of the complexities of thread creation and management.

Prefix a function or method call with the \texttt{go} keyword to run the
call in a new goroutine. When the call completes, the goroutine exits,
silently. (The effect is similar to the Unix shell's \texttt{\&}
notation for running a command in the background.)

\begin{Verbatim}[frame=single]
go list.Sort()  // run list.Sort concurrently; don't wait for it.
\end{Verbatim}

A function literal can be handy in a goroutine invocation.

\begin{Verbatim}[frame=single]
func Announce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()  // Note the parentheses - must call the function.
}
\end{Verbatim}

In Go, function literals are closures: the implementation makes sure the
variables referred to by the function survive as long as they are
active.

These examples aren't too practical because the functions have no way of
signaling completion. For that, we need channels.

\subsection*{Channels}

Like maps, channels are a reference type and are allocated with
\texttt{make}. If an optional integer parameter is provided, it sets the
buffer size for the channel. The default is zero, for an unbuffered or
synchronous channel.

\begin{Verbatim}[frame=single]
ci := make(chan int)            // unbuffered channel of integers
cj := make(chan int, 0)         // unbuffered channel of integers
cs := make(chan *os.File, 100)  // buffered channel of pointers to Files
\end{Verbatim}

Channels combine communication---the exchange of a value---with
synchronization---guaranteeing that two calculations (goroutines) are in
a known state.

There are lots of nice idioms using channels. Here's one to get us
started. In the previous section we launched a sort in the background. A
channel can allow the launching goroutine to wait for the sort to
complete.

\begin{Verbatim}[frame=single]
c := make(chan int)  // Allocate a channel.
// Start the sort in a goroutine; when it completes, signal on the channel.
go func() {
    list.Sort()
    c <- 1  // Send a signal; value does not matter.
}()
doSomethingForAWhile()
<-c   // Wait for sort to finish; discard sent value.
\end{Verbatim}

Receivers always block until there is data to receive. If the channel is
unbuffered, the sender blocks until the receiver has received the value.
If the channel has a buffer, the sender blocks only until the value has
been copied to the buffer; if the buffer is full, this means waiting
until some receiver has retrieved a value.

A buffered channel can be used like a semaphore, for instance to limit
throughput. In this example, incoming requests are passed to
\texttt{handle}, which sends a value into the channel, processes the
request, and then receives a value from the channel. The capacity of the
channel buffer limits the number of simultaneous calls to
\texttt{process}.

\begin{Verbatim}[frame=single]
var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem <- 1    // Wait for active queue to drain.
    process(r)  // May take a long time.
    <-sem       // Done; enable next request to run.
}

func Serve(queue chan *Request) {
    for {
        req := <-queue
        go handle(req)  // Don't wait for handle to finish.
    }
}
\end{Verbatim}

Here's the same idea implemented by starting a fixed number of
\texttt{handle} goroutines all reading from the request channel. The
number of goroutines limits the number of simultaneous calls to
\texttt{process}. This \texttt{Serve} function also accepts a channel on
which it will be told to exit; after launching the goroutines it blocks
receiving from that channel.

\begin{Verbatim}[frame=single]
func handle(queue chan *Request) {
    for r := range queue {
        process(r)
    }
}

func Serve(clientRequests chan *Request, quit chan bool) {
    // Start handlers
    for i := 0; i < MaxOutstanding; i++ {
        go handle(clientRequests)
    }
    <-quit  // Wait to be told to exit.
}
\end{Verbatim}

\subsection*{Channels of channels}

One of the most important properties of Go is that a channel is a
first-class value that can be allocated and passed around like any
other. A common use of this property is to implement safe, parallel
demultiplexing.

In the example in the previous section, \texttt{handle} was an idealized
handler for a request but we didn't define the type it was handling. If
that type includes a channel on which to reply, each client can provide
its own path for the answer. Here's a schematic definition of type
\texttt{Request}.

\begin{Verbatim}[frame=single]
type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}
\end{Verbatim}

The client provides a function and its arguments, as well as a channel
inside the request object on which to receive the answer.

\begin{Verbatim}[frame=single]
func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &Request{[]int{3, 4, 5}, sum, make(chan int)}
// Send request
clientRequests <- request
// Wait for response.
fmt.Printf("answer: %d\n", <-request.resultChan)
\end{Verbatim}

On the server side, the handler function is the only thing that changes.

\begin{Verbatim}[frame=single]
func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan <- req.f(req.args)
    }
}
\end{Verbatim}

There's clearly a lot more to do to make it realistic, but this code is
a framework for a rate-limited, parallel, non-blocking RPC system, and
there's not a mutex in sight.

\subsection*{Parallelization}

Another application of these ideas is to parallelize a calculation
across multiple CPU cores. If the calculation can be broken into
separate pieces that can execute independently, it can be parallelized,
with a channel to signal when each piece completes.

Let's say we have an expensive operation to perform on a vector of
items, and that the value of the operation on each item is independent,
as in this idealized example.

\begin{Verbatim}[frame=single]
type Vector []float64

// Apply the operation to v[i], v[i+1] ... up to v[n-1].
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i < n; i++ {
        v[i] += u.Op(v[i])
    }
    c <- 1    // signal that this piece is done
}
\end{Verbatim}

We launch the pieces independently in a loop, one per CPU. They can
complete in any order but it doesn't matter; we just count the
completion signals by draining the channel after launching all the
goroutines.

\begin{Verbatim}[frame=single]
const NCPU = 4  // number of CPU cores

func (v Vector) DoAll(u Vector) {
    c := make(chan int, NCPU)  // Buffering optional but sensible.
    for i := 0; i < NCPU; i++ {
        go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c)
    }
    // Drain the channel.
    for i := 0; i < NCPU; i++ {
        <-c    // wait for one task to complete
    }
    // All done.
}
\end{Verbatim}

The current implementation of the Go runtime will not parallelize this
code by default. It dedicates only a single core to user-level
processing. An arbitrary number of goroutines can be blocked in system
calls, but by default only one can be executing user-level code at any
time. It should be smarter and one day it will be smarter, but until it
is if you want CPU parallelism you must tell the run-time how many
goroutines you want executing code simultaneously. There are two related
ways to do this. Either run your job with environment variable
\texttt{GOMAXPROCS} set to the number of cores to use or import the
\texttt{runtime} package and call \texttt{runtime.GOMAXPROCS(NCPU)}. A
helpful value might be \texttt{runtime.NumCPU()}, which reports the
number of logical CPUs on the local machine. Again, this requirement is
expected to be retired as the scheduling and run-time improve.

\subsection*{A leaky buffer}

The tools of concurrent programming can even make non-concurrent ideas
easier to express. Here's an example abstracted from an RPC package. The
client goroutine loops receiving data from some source, perhaps a
network. To avoid allocating and freeing buffers, it keeps a free list,
and uses a buffered channel to represent it. If the channel is empty, a
new buffer gets allocated. Once the message buffer is ready, it's sent
to the server on \texttt{serverChan}.

\begin{Verbatim}[frame=single]
var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
    for {
        var b *Buffer
        // Grab a buffer if available; allocate if not.
        select {
        case b = <-freeList:
            // Got one; nothing more to do.
        default:
            // None free, so allocate a new one.
            b = new(Buffer)
        }
        load(b)              // Read next message from the net.
        serverChan <- b      // Send to server.
    }
}
\end{Verbatim}

The server loop receives each message from the client, processes it, and
returns the buffer to the free list.

\begin{Verbatim}[frame=single]
func server() {
    for {
        b := <-serverChan    // Wait for work.
        process(b)
        // Reuse buffer if there's room.
        select {
        case freeList <- b:
            // Buffer on free list; nothing more to do.
        default:
            // Free list full, just carry on.
        }
    }
}
\end{Verbatim}

The client attempts to retrieve a buffer from \texttt{freeList}; if none
is available, it allocates a fresh one. The server's send to
\texttt{freeList} puts \texttt{b} back on the free list unless the list
is full, in which case the buffer is dropped on the floor to be
reclaimed by the garbage collector. (The \texttt{default} clauses in the
\texttt{select} statements execute when no other case is ready, meaning
that the \texttt{selects} never block.) This implementation builds a
leaky bucket free list in just a few lines, relying on the buffered
channel and the garbage collector for bookkeeping.

\section*{Errors}

Library routines must often return some sort of error indication to the
caller. As mentioned earlier, Go's multivalue return makes it easy to
return a detailed error description alongside the normal return value.
By convention, errors have type \texttt{error}, a simple built-in
interface.

\begin{Verbatim}[frame=single]
type error interface {
    Error() string
}
\end{Verbatim}

A library writer is free to implement this interface with a richer model
under the covers, making it possible not only to see the error but also
to provide some context. For example, \texttt{os.Open} returns an
\texttt{os.PathError}.

\begin{Verbatim}[frame=single]
// PathError records an error and the operation and
// file path that caused it.
type PathError struct {
    Op string    // "open", "unlink", etc.
    Path string  // The associated file.
    Err error    // Returned by the system call.
}

func (e *PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
\end{Verbatim}

\texttt{PathError}'s \texttt{Error} generates a string like this:

\begin{Verbatim}[frame=single]
open /etc/passwx: no such file or directory
\end{Verbatim}

Such an error, which includes the problematic file name, the operation,
and the operating system error it triggered, is useful even if printed
far from the call that caused it; it is much more informative than the
plain ``no such file or directory''.

When feasible, error strings should identify their origin, such as by
having a prefix naming the package that generated the error. For
example, in package \texttt{image}, the string representation for a
decoding error due to an unknown format is ``image: unknown format''.

Callers that care about the precise error details can use a type switch
or a type assertion to look for specific errors and extract details. For
\texttt{PathErrors} this might include examining the internal
\texttt{Err} field for recoverable failures.

\begin{Verbatim}[frame=single]
for try := 0; try < 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
    if e, ok := err.(*os.PathError); ok && e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
\end{Verbatim}

The second \texttt{if} statement here is idiomatic Go. The type
assertion \texttt{err.(*os.PathError)} is checked with the ``comma
ok'' idiom (mentioned earlier in the context of examining maps).
If the type assertion fails, \texttt{ok} will be false, and \texttt{e}
will be \texttt{nil}. If it succeeds, \texttt{ok} will be true,
which means the error was of type \texttt{*os.PathError}, and then
so is \texttt{e}, which we can examine for more information about
the error.

\subsection*{Panic}

The usual way to report an error to a caller is to return an
\texttt{error} as an extra return value. The canonical \texttt{Read}
method is a well-known instance; it returns a byte count and an
\texttt{error}. But what if the error is unrecoverable? Sometimes the
program simply cannot continue.

For this purpose, there is a built-in function \texttt{panic} that in
effect creates a run-time error that will stop the program (but see the
next section). The function takes a single argument of arbitrary
type---often a string---to be printed as the program dies. It's also a
way to indicate that something impossible has happened, such as exiting
an infinite loop. In fact, the compiler recognizes a \texttt{panic} at
the end of a function and suppresses the usual check for a
\texttt{return} statement.

\begin{Verbatim}[frame=single]
// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
    z := x/3   // Arbitrary initial value
    for i := 0; i < 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // A million iterations has not converged; something is wrong.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
\end{Verbatim}

This is only an example but real library functions should avoid
\texttt{panic}. If the problem can be masked or worked around, it's
always better to let things continue to run rather than taking down the
whole program. One possible counterexample is during initialization: if
the library truly cannot set itself up, it might be reasonable to panic,
so to speak.

\begin{Verbatim}[frame=single]
var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}
\end{Verbatim}

\subsection*{Recover}

When \texttt{panic} is called, including implicitly for run-time errors
such as indexing an array out of bounds or failing a type assertion, it
immediately stops execution of the current function and begins unwinding
the stack of the goroutine, running any deferred functions along the
way. If that unwinding reaches the top of the goroutine's stack, the
program dies. However, it is possible to use the built-in function
\texttt{recover} to regain control of the goroutine and resume normal
execution.

A call to \texttt{recover} stops the unwinding and returns the argument
passed to \texttt{panic}. Because the only code that runs while
unwinding is inside deferred functions, \texttt{recover} is only useful
inside deferred functions.

One application of \texttt{recover} is to shut down a failing goroutine
inside a server without killing the other executing goroutines.

\begin{Verbatim}[frame=single]
func server(workChan <-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
\end{Verbatim}

In this example, if \texttt{do(work)} panics, the result will be logged
and the goroutine will exit cleanly without disturbing the others.
There's no need to do anything else in the deferred closure; calling
\texttt{recover} handles the condition completely.

Because \texttt{recover} always returns \texttt{nil} unless called
directly from a deferred function, deferred code can call library
routines that themselves use \texttt{panic} and \texttt{recover} without
failing. As an example, the deferred function in \texttt{safelyDo} might
call a logging function before calling \texttt{recover}, and that
logging code would run unaffected by the panicking state.

With our recovery pattern in place, the \texttt{do} function (and
anything it calls) can get out of any bad situation cleanly by calling
\texttt{panic}. We can use that idea to simplify error handling in
complex software. Let's look at an idealized excerpt from the
\texttt{regexp} package, which reports parsing errors by calling
\texttt{panic} with a local error type. Here's the definition of
\texttt{Error}, an \texttt{error} method, and the \texttt{Compile}
function.

\begin{Verbatim}[frame=single]
// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}
\end{Verbatim}

If \texttt{doParse} panics, the recovery block will set the return value
to \texttt{nil}---deferred functions can modify named return values. It
then will then check, in the assignment to \texttt{err}, that the
problem was a parse error by asserting that it has the local type
\texttt{Error}. If it does not, the type assertion will fail, causing a
run-time error that continues the stack unwinding as though nothing had
interrupted it. This check means that if something unexpected happens,
such as an array index out of bounds, the code will fail even though we
are using \texttt{panic} and \texttt{recover} to handle user-triggered
errors.

With error handling in place, the \texttt{error} method makes it easy to
report parse errors without worrying about unwinding the parse stack by
hand.

Useful though this pattern is, it should be used only within a package.
\texttt{Parse} turns its internal \texttt{panic} calls into
\texttt{error} values; it does not expose \texttt{panics} to its client.
That is a good rule to follow.

By the way, this re-panic idiom changes the panic value if an actual
error occurs. However, both the original and new failures will be
presented in the crash report, so the root cause of the problem will
still be visible. Thus this simple re-panic approach is usually
sufficient---it's a crash after all---but if you want to display only
the original value, you can write a little more code to filter
unexpected problems and re-panic with the original error. That's left as
an exercise for the reader.

\section*{A web server}

Let's finish with a complete Go program, a web server. This one is
actually a kind of web re-server. Google provides a service at
\href{http://chart.apis.google.com}{http://chart.apis.google.com} that
does automatic formatting of data into charts and graphs. It's hard to
use interactively, though, because you need to put the data into the URL
as a query. The program here provides a nicer interface to one form of
data: given a short piece of text, it calls on the chart server to
produce a QR code, a matrix of boxes that encode the text. That image
can be grabbed with your cell phone's camera and interpreted as, for
instance, a URL, saving you typing the URL into the phone's tiny
keyboard.

Here's the complete program. An explanation follows.

\{\{code ``/doc/progs/eff\_qr.go''\}\}

The pieces up to \texttt{main} should be easy to follow. The one flag
sets a default HTTP port for our server. The template variable
\texttt{templ} is where the fun happens. It builds an HTML template that
will be executed by the server to display the page; more about that in a
moment.

The \texttt{main} function parses the flags and, using the mechanism we
talked about above, binds the function \texttt{QR} to the root path for
the server. Then \texttt{http.ListenAndServe} is called to start the
server; it blocks while the server runs.

\texttt{QR} just receives the request, which contains form data, and
executes the template on the data in the form value named \texttt{s}.

The template package \texttt{html/template} is powerful; this program
just touches on its capabilities. In essence, it rewrites a piece of
HTML text on the fly by substituting elements derived from data items
passed to \texttt{templ.Execute}, in this case the form value. Within
the template text (\texttt{templateStr}), double-brace-delimited pieces
denote template actions. The piece from
\texttt{\{\{html "\{\{if .\}\}"\}\}} to
\texttt{\{\{html "\{\{end\}\}"\}\}} executes only if the value of the
current data item, called \texttt{.} (dot), is non-empty. That is, when
the string is empty, this piece of the template is suppressed.

The two snippets \texttt{\{\{html "\{\{.\}\}"\}\}} say to show the data
presented to the template---the query string---on the web page. The HTML
template package automatically provides appropriate escaping so the text
is safe to display.

The rest of the template string is just the HTML to show when the page
loads. If this is too quick an explanation, see the
\href{/pkg/html/template/}{documentation} for the template package for a
more thorough discussion.

And there you have it: a useful web server in a few lines of code plus
some data-driven HTML text. Go is powerful enough to make a lot happen
in a few lines.
