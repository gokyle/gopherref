\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Go Language Specification}
\appendix
\chapter*{Go Language Specification}

\section*{Introduction}

This is a reference manual for the Go programming language. For more
information and other documents, see
\href{http://golang.org/}{http://golang.org}.

Go is a general-purpose language designed with systems programming in
mind. It is strongly typed and garbage-collected and has explicit
support for concurrent programming. Programs are constructed from
\emph{packages}, whose properties allow efficient management of
dependencies. The existing implementations use a traditional
compile/link model to generate executable binaries.

The grammar is compact and regular, allowing for easy analysis by
automatic tools such as integrated development environments.

\section*{Notation}

The syntax is specified using Extended Backus-Naur Form (EBNF):

\begin{Verbatim}[frame=single]
Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ "…" token ] | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
\end{Verbatim}

Productions are expressions constructed from terms and the following
operators, in increasing precedence:

\begin{Verbatim}[frame=single]
|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)
\end{Verbatim}

Lower-case production names are used to identify lexical tokens.
Non-terminals are in CamelCase. Lexical tokens are enclosed in double
quotes \texttt{""} or back quotes \texttt{``}.

The form \texttt{a \ldots{} b} represents the set of characters from
\texttt{a} through \texttt{b} as alternatives. The horizontal ellipsis
\texttt{\ldots{}} is also used elsewhere in the spec to informally
denote various enumerations or code snippets that are not further
specified. The character \texttt{\ldots{}} (as opposed to the three
characters \texttt{...}) is not a token of the Go language.

\section*{Source code representation}

Source code is Unicode text encoded in
\href{http://en.wikipedia.org/wiki/UTF-8}{UTF-8}. The text is not
canonicalized, so a single accented code point is distinct from the same
character constructed from combining an accent and a letter; those are
treated as two code points. For simplicity, this document will use the
unqualified term \emph{character} to refer to a Unicode code point in
the source text.

Each code point is distinct; for instance, upper and lower case letters
are different characters.

Implementation restriction: For compatibility with other tools, a
compiler may disallow the NUL character (U+0000) in the source text.

\subsection*{Characters}

The following terms are used to denote specific Unicode character
classes:

\begin{Verbatim}[frame=single]
newline        = /* the Unicode code point U+000A */ .
unicode_char   = /* an arbitrary Unicode code point except newline */ .
unicode_letter = /* a Unicode code point classified as "Letter" */ .
unicode_digit  = /* a Unicode code point classified as "Decimal Digit" */ .
\end{Verbatim}

In \href{http://www.unicode.org/versions/Unicode6.0.0/}{The Unicode
Standard 6.0}, Section 4.5 ``General Category'' defines a set of
character categories. Go treats those characters in category Lu, Ll, Lt,
Lm, or Lo as Unicode letters, and those in category Nd as Unicode
digits.

\subsection*{Letters and digits}

The underscore character \texttt{\_} (U+005F) is considered a letter.

\begin{Verbatim}[frame=single]
letter        = unicode_letter | "_" .
decimal_digit = "0" … "9" .
octal_digit   = "0" … "7" .
hex_digit     = "0" … "9" | "A" … "F" | "a" … "f" .
\end{Verbatim}

\section*{Lexical elements}

\subsection*{Comments}

There are two forms of comments:

\begin{enumerate}
\item
  \emph{Line comments} start with the character sequence \texttt{//} and
  stop at the end of the line. A line comment acts like a newline.
\item
  \emph{General comments} start with the character sequence \texttt{/*}
  and continue through the character sequence \texttt{*/}. A general
  comment containing one or more newlines acts like a newline, otherwise
  it acts like a space.
\end{enumerate}

Comments do not nest.

\subsection*{Tokens}

Tokens form the vocabulary of the Go language. There are four classes:
\emph{identifiers}, \emph{keywords}, \emph{operators and delimiters},
and \emph{literals}. \emph{White space}, formed from spaces (U+0020),
horizontal tabs (U+0009), carriage returns (U+000D), and newlines
(U+000A), is ignored except as it separates tokens that would otherwise
combine into a single token. Also, a newline or end of file may trigger
the insertion of a semicolon. While breaking the
input into tokens, the next token is the longest sequence of characters
that form a valid token.

\subsection*{Semicolons}

The formal grammar uses semicolons \texttt{";"} as terminators in a
number of productions. Go programs may omit most of these semicolons
using the following two rules:

\begin{enumerate}
\item
  When the input is broken into tokens, a semicolon is automatically
  inserted into the token stream at the end of a non-blank line if the
  line's final token is

  \begin{itemize}
  \item
    an identifier
  \item
    an integer,
    floating-point,
    imaginary,
    rune, or
    string literal
  \item
    one of the keywords \texttt{break},
    \texttt{continue}, \texttt{fallthrough}, or \texttt{return}
  \item
    one of the operators and delimiters \texttt{++}, \texttt{-{}-},
    \texttt{)}, \texttt{]}, or \texttt{\}}
  \end{itemize}
\item
  To allow complex statements to occupy a single line, a semicolon may
  be omitted before a closing \texttt{")"} or \texttt{"\}"}.
\end{enumerate}

To reflect idiomatic use, code examples in this document elide
semicolons using these rules.

\subsection*{Identifiers}

Identifiers name program entities such as variables and types. An
identifier is a sequence of one or more letters and digits. The first
character in an identifier must be a letter.

\begin{Verbatim}[frame=single]
identifier = letter { letter | unicode_digit } .
\end{Verbatim}

\begin{Verbatim}[frame=single]
a
_x9
ThisVariableIsExported
αβ
\end{Verbatim}

Some identifiers are predeclared.

\subsection*{Keywords}

The following keywords are reserved and may not be used as identifiers.

\begin{Verbatim}[frame=single]
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
\end{Verbatim}

\subsection*{Operators and Delimiters}

The following character sequences represent
operators, delimiters, and other special tokens:

\begin{Verbatim}[frame=single]
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
*    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=
\end{Verbatim}

\subsection*{Integer literals}

An integer literal is a sequence of digits representing an
integer constant. An optional prefix sets a
non-decimal base: \texttt{0} for octal, \texttt{0x} or \texttt{0X} for
hexadecimal. In hexadecimal literals, letters \texttt{a-f} and
\texttt{A-F} represent values 10 through 15.

\begin{Verbatim}[frame=single]
int_lit     = decimal_lit | octal_lit | hex_lit .
decimal_lit = ( "1" … "9" ) { decimal_digit } .
octal_lit   = "0" { octal_digit } .
hex_lit     = "0" ( "x" | "X" ) hex_digit { hex_digit } .
\end{Verbatim}

\begin{Verbatim}[frame=single]
42
0600
0xBadFace
170141183460469231731687303715884105727
\end{Verbatim}

\subsection*{Floating-point literals}

A floating-point literal is a decimal representation of a
floating-point constant. It has an integer part, a
decimal point, a fractional part, and an exponent part. The integer and
fractional part comprise decimal digits; the exponent part is an
\texttt{e} or \texttt{E} followed by an optionally signed decimal
exponent. One of the integer part or the fractional part may be elided;
one of the decimal point or the exponent may be elided.

\begin{Verbatim}[frame=single]
float_lit = decimals "." [ decimals ] [ exponent ] |
            decimals exponent |
            "." decimals [ exponent ] .
decimals  = decimal_digit { decimal_digit } .
exponent  = ( "e" | "E" ) [ "+" | "-" ] decimals .
\end{Verbatim}

\begin{Verbatim}[frame=single]
0.
72.40
072.40  // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
\end{Verbatim}

\subsection*{Imaginary literals}

An imaginary literal is a decimal representation of the imaginary part
of a complex constant. It consists of a
floating-point literal or decimal
integer followed by the lower-case letter \texttt{i}.

\begin{Verbatim}[frame=single]
imaginary_lit = (decimals | float_lit) "i" .
\end{Verbatim}

\begin{Verbatim}[frame=single]
0i
011i  // == 11i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
\end{Verbatim}

\subsection*{Rune literals}

A rune literal represents a rune constant, an
integer value identifying a Unicode code point. A rune literal is
expressed as one or more characters enclosed in single quotes. Within
the quotes, any character may appear except single quote and newline. A
single quoted character represents the Unicode value of the character
itself, while multi-character sequences beginning with a backslash
encode values in various formats.

The simplest form represents the single character within the quotes;
since Go source text is Unicode characters encoded in UTF-8, multiple
UTF-8-encoded bytes may represent a single integer value. For instance,
the literal \texttt{'a'} holds a single byte representing a literal
\texttt{a}, Unicode U+0061, value \texttt{0x61}, while \texttt{'ä'}
holds two bytes (\texttt{0xc3} \texttt{0xa4}) representing a literal
\texttt{a}-dieresis, U+00E4, value \texttt{0xe4}.

Several backslash escapes allow arbitrary values to be encoded as ASCII
text. There are four ways to represent the integer value as a numeric
constant: \texttt{\textbackslash{}x} followed by exactly two hexadecimal
digits; \texttt{\textbackslash{}u} followed by exactly four hexadecimal
digits; \texttt{\textbackslash{}U} followed by exactly eight hexadecimal
digits, and a plain backslash \texttt{\textbackslash{}} followed by
exactly three octal digits. In each case the value of the literal is the
value represented by the digits in the corresponding base.

Although these representations all result in an integer, they have
different valid ranges. Octal escapes must represent a value between 0
and 255 inclusive. Hexadecimal escapes satisfy this condition by
construction. The escapes \texttt{\textbackslash{}u} and
\texttt{\textbackslash{}U} represent Unicode code points so within them
some values are illegal, in particular those above \texttt{0x10FFFF} and
surrogate halves.

After a backslash, certain single-character escapes represent special
values:

\begin{Verbatim}[frame=single]
\a   U+0007 alert or bell
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed or newline
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000b vertical tab
\\   U+005c backslash
\'   U+0027 single quote  (valid escape only within rune literals)
\"   U+0022 double quote  (valid escape only within string literals)
\end{Verbatim}

All other sequences starting with a backslash are illegal inside rune
literals.

\begin{Verbatim}[frame=single]
char_lit         = "'" ( unicode_value | byte_value ) "'" .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` "x" hex_digit hex_digit .
little_u_value   = `\` "u" hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` "U" hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .
\end{Verbatim}

\begin{Verbatim}[frame=single]
'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'aa'         // illegal: too many characters
'\xa'        // illegal: too few hexadecimal digits
'\0'         // illegal: too few octal digits
'\uDFFF'     // illegal: surrogate half
'\U00110000' // illegal: invalid Unicode code point
\end{Verbatim}

\subsection*{String literals}

A string literal represents a string constant
obtained from concatenating a sequence of characters. There are two
forms: raw string literals and interpreted string literals.

Raw string literals are character sequences between back quotes
\texttt{``}. Within the quotes, any character is legal except back
quote. The value of a raw string literal is the string composed of the
uninterpreted (implicitly UTF-8-encoded) characters between the quotes;
in particular, backslashes have no special meaning and the string may
contain newlines. Carriage returns inside raw string literals are
discarded from the raw string value.

Interpreted string literals are character sequences between double
quotes \texttt{""}. The text between the quotes, which may not contain
newlines, forms the value of the literal, with backslash escapes
interpreted as they are in rune literals (except that
\texttt{\textbackslash{}'} is illegal and \texttt{\textbackslash{}"} is
legal), with the same restrictions. The three-digit octal
(\texttt{\textbackslash{}}\emph{nnn}) and two-digit hexadecimal
(\texttt{\textbackslash{}x}\emph{nn}) escapes represent individual
\emph{bytes} of the resulting string; all other escapes represent the
(possibly multi-byte) UTF-8 encoding of individual \emph{characters}.
Thus inside a string literal \texttt{\textbackslash{}377} and
\texttt{\textbackslash{}xFF} represent a single byte of value
\texttt{0xFF}=255, while \texttt{ÿ}, \texttt{\textbackslash{}u00FF},
\texttt{\textbackslash{}U000000FF} and
\texttt{\textbackslash{}xc3\textbackslash{}xbf} represent the two bytes
\texttt{0xc3} \texttt{0xbf} of the UTF-8 encoding of character U+00FF.

\begin{Verbatim}[frame=single]
string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = "`" { unicode_char | newline } "`" .
interpreted_string_lit = `"` { unicode_value | byte_value } `"` .
\end{Verbatim}

\begin{Verbatim}[frame=single]
`abc`  // same as "abc"
`\n
\n`    // same as "\\n\n\\n"
"\n"
""
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"       // illegal: surrogate half
"\U00110000"   // illegal: invalid Unicode code point
\end{Verbatim}

These examples all represent the same string:

\begin{Verbatim}[frame=single]
"日本語"                                 // UTF-8 input text
`日本語`                                 // UTF-8 input text as a raw literal
"\u65e5\u672c\u8a9e"                    // the explicit Unicode code points
"\U000065e5\U0000672c\U00008a9e"        // the explicit Unicode code points
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // the explicit UTF-8 bytes
\end{Verbatim}

If the source code represents a character as two code points, such as a
combining form involving an accent and a letter, the result will be an
error if placed in a rune literal (it is not a single code point), and
will appear as two code points if placed in a string literal.

\section*{Constants}

There are \emph{boolean constants}, \emph{rune constants}, \emph{integer
constants}, \emph{floating-point constants}, \emph{complex constants},
and \emph{string constants}. Character, integer, floating-point, and
complex constants are collectively called \emph{numeric constants}.

A constant value is represented by a rune, integer, floating-point,
imaginary, or string literal, an identifier denoting a constant, a
constant expression, a conversion with a result that is a constant,
or the result value of some built-in functions such as
\texttt{unsafe.Sizeof} applied to any value, \texttt{cap} or
\texttt{len} applied to some expressions, \texttt{real} and
\texttt{imag} applied to a complex constant and \texttt{complex}
applied to numeric constants. The boolean truth values are represented
by the predeclared constants \texttt{true} and \texttt{false}. The
predeclared identifier iota denotes an integer constant.

In general, complex constants are a form of
constant expression and are discussed
in that section.

Numeric constants represent values of arbitrary precision and do not
overflow.

Constants may be typed or untyped. Literal constants,
\texttt{true}, \texttt{false}, \texttt{iota}, and certain
constant expressions containing only
untyped constant operands are untyped.

A constant may be given a type explicitly by a
constant declaration or
conversion, or implicitly when used in a
variable declaration or an
assignment or as an operand in an
expression. It is an error if the constant value
cannot be represented as a value of the respective type. For instance,
\texttt{3.0} can be given any integer or any floating-point type, while
\texttt{2147483648.0} (equal to \texttt{1\textless{}\textless{}31}) can
be given the types \texttt{float32}, \texttt{float64}, or
\texttt{uint32} but not \texttt{int32} or \texttt{string}.

There are no constants denoting the IEEE-754 infinity and not-a-number
values, but the \href{/pkg/math/}{\texttt{math} package}'s
\href{/pkg/math/\#Inf}{Inf}, \href{/pkg/math/\#NaN}{NaN},
\href{/pkg/math/\#IsInf}{IsInf}, and \href{/pkg/math/\#IsNaN}{IsNaN}
functions return and test for those values at run time.

Implementation restriction: Although numeric constants have arbitrary
precision in the language, a compiler may implement them using an
internal representation with limited precision. That said, every
implementation must:

\begin{itemize}
\item
  Represent integer constants with at least 256 bits.
\item
  Represent floating-point constants, including the parts of a complex
  constant, with a mantissa of at least 256 bits and a signed exponent
  of at least 32 bits.
\item
  Give an error if unable to represent an integer constant precisely.
\item
  Give an error if unable to represent a floating-point or complex
  constant due to overflow.
\item
  Round to the nearest representable constant if unable to represent a
  floating-point or complex constant due to limits on precision.
\end{itemize}

These requirements apply both to literal constants and to the result of
evaluating constant expressions.

\section*{Types}

A type determines the set of values and operations specific to
values of that type. A type may be specified by a (possibly qualified)
\emph{type name} a \emph{type literal}, which composes a new type
from previously declared types.

\begin{Verbatim}[frame=single]
Type      = TypeName | TypeLit | "(" Type ")" .
TypeName  = identifier | QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
        SliceType | MapType | ChannelType .
\end{Verbatim}

Named instances of the boolean, numeric, and string types are
predeclared. \emph{Composite
types}---array, struct, pointer, function, interface, slice, map, and
channel types---may be constructed using type literals.

The \emph{static type} (or just \emph{type}) of a variable is the type
defined by its declaration. Variables of interface type also have a
distinct \emph{dynamic type}, which is the actual type of the value
stored in the variable at run-time. The dynamic type may vary during
execution but is always assignable to the
static type of the interface variable. For non-interface types, the
dynamic type is always the static type.

Each type \texttt{T} has an \emph{underlying type}: If \texttt{T} is a
predeclared type or a type literal, the corresponding underlying type is
\texttt{T} itself. Otherwise, \texttt{T}'s underlying type is the
underlying type of the type to which \texttt{T} refers in its
type declaration.

\begin{Verbatim}[frame=single]
   type T1 string
   type T2 T1
   type T3 []T1
   type T4 T3
\end{Verbatim}

The underlying type of \texttt{string}, \texttt{T1}, and \texttt{T2} is
\texttt{string}. The underlying type of \texttt{{[}{]}T1}, \texttt{T3},
and \texttt{T4} is \texttt{{[}{]}T1}.

\subsection*{Method sets}

A type may have a \emph{method set} associated with it. The method
set of an interface type is its interface. The method set of any
other type \texttt{T} consists of all methods with receiver type
\texttt{T}. The method set of the corresponding pointer type
\texttt{*T} is the set of all methods with receiver \texttt{*T} or
\texttt{T} (that is, it also contains the method set of \texttt{T}).
Further rules apply to structs containing anonymous fields, as
described in the section on struct types. Any other type has an
empty method set. In a method set, each method must have a unique
method name.

The method set of a type determines the interfaces that the type
implements and the methods that can be
called using a receiver of that type.

\subsection*{Boolean types}

A \emph{boolean type} represents the set of Boolean truth values denoted
by the predeclared constants \texttt{true} and \texttt{false}. The
predeclared boolean type is \texttt{bool}.

\subsection*{Numeric types}

A \emph{numeric type} represents sets of integer or floating-point
values. The predeclared architecture-independent numeric types are:

\begin{Verbatim}[frame=single]
uint8       the set of all unsigned  8-bit integers (0 to 255)
uint16      the set of all unsigned 16-bit integers (0 to 65535)
uint32      the set of all unsigned 32-bit integers (0 to 4294967295)
uint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE-754 32-bit floating-point numbers
float64     the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts

byte        alias for uint8
rune        alias for int32
\end{Verbatim}

The value of an \emph{n}-bit integer is \emph{n} bits wide and
represented using
\href{http://en.wikipedia.org/wiki/Two's\_complement}{two's complement
arithmetic}.

There is also a set of predeclared numeric types with
implementation-specific sizes:

\begin{Verbatim}[frame=single]
uint     either 32 or 64 bits
int      same size as uint
uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value
\end{Verbatim}

To avoid portability issues all numeric types are distinct except
\texttt{byte}, which is an alias for \texttt{uint8}, and \texttt{rune},
which is an alias for \texttt{int32}. Conversions are required when
different numeric types are mixed in an expression or assignment. For
instance, \texttt{int32} and \texttt{int} are not the same type even
though they may have the same size on a particular architecture.

\subsection*{String types}

A \emph{string type} represents the set of string values. Strings behave
like slices of bytes but are immutable: once created, it is impossible
to change the contents of a string. The predeclared string type is
\texttt{string}.

The elements of strings have type \texttt{byte} and may be accessed
using the usual indexing operations. It is illegal
to take the address of such an element; if \texttt{s{[}i{]}} is the
\emph{i}th byte of a string, \texttt{\&s{[}i{]}} is invalid. The length
of string \texttt{s} can be discovered using the built-in function
\texttt{len}. The length is a compile-time constant if \texttt{s} is a
string literal.

\subsection*{Array types}

An array is a numbered sequence of elements of a single type, called the
element type. The number of elements is called the length and is never
negative.

\begin{Verbatim}[frame=single]
ArrayType   = "[" ArrayLength "]" ElementType .
ArrayLength = Expression .
ElementType = Type .
\end{Verbatim}

The length is part of the array's type and must be a constant
expression that evaluates to a non-negative integer value. The
length of array \texttt{a} can be discovered using the built-in
function \texttt{len(a)}. The elements can be indexed by integer
indices 0 through \texttt{len(a)-1}. Array types are always
one-dimensional but may be composed to form multi-dimensional types.

\begin{Verbatim}[frame=single]
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // same as [2]([2]([2]float64))
\end{Verbatim}

\subsection*{Slice types}

A slice is a reference to a contiguous segment of an array and contains
a numbered sequence of elements from that array. A slice type denotes
the set of all slices of arrays of its element type. The value of an
uninitialized slice is \texttt{nil}.

\begin{Verbatim}[frame=single]
SliceType = "[" "]" ElementType .
\end{Verbatim}

Like arrays, slices are indexable and have a length. The length of
a slice \texttt{s} can be discovered by the built-in function
\texttt{len(s)}; unlike with arrays it may change during execution.
The elements can be addressed by integer indices 0 through
\texttt{len(s)-1}. The slice index of a given element may be less
than the index of the same element in the underlying array.

A slice, once initialized, is always associated with an underlying array
that holds its elements. A slice therefore shares storage with its array
and with other slices of the same array; by contrast, distinct arrays
always represent distinct storage.

The array underlying a slice may extend past the end of the slice.
The \emph{capacity} is a measure of that extent: it is the sum of
the length of the slice and the length of the array beyond the
slice; a slice of length up to that capacity can be created by
`slicing' a new one from the original slice. The capacity of a slice
\texttt{a} can be discovered using the built-in function \texttt{cap(a)}.

A new, initialized slice value for a given element type \texttt{T} is
made using the built-in function
\texttt{make}, which
takes a slice type and parameters specifying the length and optionally
the capacity:

\begin{Verbatim}[frame=single]
make([]T, length)
make([]T, length, capacity)
\end{Verbatim}

A call to \texttt{make} allocates a new, hidden array to which the
returned slice value refers. That is, executing

\begin{Verbatim}[frame=single]
make([]T, length, capacity)
\end{Verbatim}

produces the same slice as allocating an array and slicing it, so these
two examples result in the same slice:

\begin{Verbatim}[frame=single]
make([]int, 50, 100)
new([100]int)[0:50]
\end{Verbatim}

Like arrays, slices are always one-dimensional but may be composed to
construct higher-dimensional objects. With arrays of arrays, the inner
arrays are, by construction, always the same length; however with slices
of slices (or arrays of slices), the lengths may vary dynamically.
Moreover, the inner slices must be allocated individually (with
\texttt{make}).

\subsection*{Struct types}

A struct is a sequence of named elements, called fields, each of which
has a name and a type. Field names may be specified explicitly
(IdentifierList) or implicitly (AnonymousField). Within a struct,
non-blank field names must be
unique.

\begin{Verbatim}[frame=single]
StructType     = "struct" "{" { FieldDecl ";" } "}" .
FieldDecl      = (IdentifierList Type | AnonymousField) [ Tag ] .
AnonymousField = [ "*" ] TypeName .
Tag            = string_lit .
\end{Verbatim}

\begin{Verbatim}[frame=single]
// An empty struct.
struct {}

// A struct with 6 fields.
struct {
    x, y int
    u float32
    _ float32  // padding
    A *[]int
    F func()
}
\end{Verbatim}

A field declared with a type but no explicit field name is an
\emph{anonymous field}, also called an \emph{embedded} field or an
embedding of the type in the struct. An embedded type must be specified
as a type name \texttt{T} or as a pointer to a non-interface type name
\texttt{*T}, and \texttt{T} itself may not be a pointer type. The
unqualified type name acts as the field name.

\begin{Verbatim}[frame=single]
// A struct with four anonymous fields of type T1, *T2, P.T3 and *P.T4
struct {
    T1        // field name is T1
    *T2       // field name is T2
    P.T3      // field name is T3
    *P.T4     // field name is T4
    x, y int  // field names are x and y
}
\end{Verbatim}

The following declaration is illegal because field names must be unique
in a struct type:

\begin{Verbatim}[frame=single]
struct {
    T     // conflicts with anonymous field *T and *P.T
    *T    // conflicts with anonymous field T and *P.T
    *P.T  // conflicts with anonymous field T and *T
}
\end{Verbatim}

A field or method \texttt{f} of an
anonymous field in a struct \texttt{x} is called \emph{promoted} if
\texttt{x.f} is a legal selector that denotes that
field or method \texttt{f}.

Promoted fields act like ordinary fields of a struct except that they
cannot be used as field names in
composite literals of the struct.

Given a struct type \texttt{S} and a type named \texttt{T}, promoted
methods are included in the method set of the struct as follows:

\begin{itemize}
\item
  If \texttt{S} contains an anonymous field \texttt{T}, the
  method sets of \texttt{S} and \texttt{*S}
  both include promoted methods with receiver \texttt{T}. The method set
  of \texttt{*S} also includes promoted methods with receiver
  \texttt{*T}.
\item
  If \texttt{S} contains an anonymous field \texttt{*T}, the method sets
  of \texttt{S} and \texttt{*S} both include promoted methods with
  receiver \texttt{T} or \texttt{*T}.
\end{itemize}

A field declaration may be followed by an optional string literal
\emph{tag}, which becomes an attribute for all the fields in the
corresponding field declaration. The tags are made visible through a
reflection interface but are otherwise
ignored.

\begin{Verbatim}[frame=single]
// A struct corresponding to the TimeStamp protocol buffer.
// The tag strings define the protocol buffer field numbers.
struct {
    microsec  uint64 "field 1"
    serverIP6 uint64 "field 2"
    process   string "field 3"
}
\end{Verbatim}

\subsection*{Pointer types}

A pointer type denotes the set of all pointers to variables of a given
type, called the \emph{base type} of the pointer. The value of an
uninitialized pointer is \texttt{nil}.

\begin{Verbatim}[frame=single]
PointerType = "*" BaseType .
BaseType = Type .
\end{Verbatim}

\begin{Verbatim}[frame=single]
*Point
*[4]int
\end{Verbatim}

\subsection*{Function types}

A function type denotes the set of all functions with the same parameter
and result types. The value of an uninitialized variable of function
type is \texttt{nil}.

\begin{Verbatim}[frame=single]
FunctionType   = "func" Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = "(" [ ParameterList [ "," ] ] ")" .
ParameterList  = ParameterDecl { "," ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
\end{Verbatim}

Within a list of parameters or results, the names (IdentifierList) must
either all be present or all be absent. If present, each name stands for
one item (parameter or result) of the specified type; if absent, each
type stands for one item of that type. Parameter and result lists are
always parenthesized except that if there is exactly one unnamed result
it may be written as an unparenthesized type.

The final parameter in a function signature may have a type prefixed
with \texttt{...}. A function with such a parameter is called
\emph{variadic} and may be invoked with zero or more arguments for that
parameter.

\begin{Verbatim}[frame=single]
func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
\end{Verbatim}

\subsection*{Interface types}

An interface type specifies a method set called
its \emph{interface}. A variable of interface type can store a value of
any type with a method set that is any superset of the interface. Such a
type is said to \emph{implement the interface}. The value of an
uninitialized variable of interface type is \texttt{nil}.

\begin{Verbatim}[frame=single]
InterfaceType      = "interface" "{" { MethodSpec ";" } "}" .
MethodSpec         = MethodName Signature | InterfaceTypeName .
MethodName         = identifier .
InterfaceTypeName  = TypeName .
\end{Verbatim}

As with all method sets, in an interface type, each method must have a
unique name.

\begin{Verbatim}[frame=single]
// A simple File interface
interface {
    Read(b Buffer) bool
    Write(b Buffer) bool
    Close()
}
\end{Verbatim}

More than one type may implement an interface. For instance, if two
types \texttt{S1} and \texttt{S2} have the method set

\begin{Verbatim}[frame=single]
func (p T) Read(b Buffer) bool { return … }
func (p T) Write(b Buffer) bool { return … }
func (p T) Close() { … }
\end{Verbatim}

(where \texttt{T} stands for either \texttt{S1} or \texttt{S2}) then the
\texttt{File} interface is implemented by both \texttt{S1} and
\texttt{S2}, regardless of what other methods \texttt{S1} and
\texttt{S2} may have or share.

A type implements any interface comprising any subset of its methods and
may therefore implement several distinct interfaces. For instance, all
types implement the \emph{empty interface}:

\begin{Verbatim}[frame=single]
interface{}
\end{Verbatim}

Similarly, consider this interface specification, which appears within a
type declaration to define an interface
called \texttt{Lock}:

\begin{Verbatim}[frame=single]
type Lock interface {
    Lock()
    Unlock()
}
\end{Verbatim}

If \texttt{S1} and \texttt{S2} also implement

\begin{Verbatim}[frame=single]
func (p T) Lock() { … }
func (p T) Unlock() { … }
\end{Verbatim}

they implement the \texttt{Lock} interface as well as the \texttt{File}
interface.

An interface may use an interface type name \texttt{T} in place of a
method specification. The effect, called embedding an interface, is
equivalent to enumerating the methods of \texttt{T} explicitly in the
interface.

\begin{Verbatim}[frame=single]
type ReadWrite interface {
    Read(b Buffer) bool
    Write(b Buffer) bool
}

type File interface {
    ReadWrite  // same as enumerating the methods in ReadWrite
    Lock       // same as enumerating the methods in Lock
    Close()
}
\end{Verbatim}

An interface type \texttt{T} may not embed itself or any interface type
that embeds \texttt{T}, recursively.

\begin{Verbatim}[frame=single]
// illegal: Bad cannot embed itself
type Bad interface {
    Bad
}

// illegal: Bad1 cannot embed itself using Bad2
type Bad1 interface {
    Bad2
}
type Bad2 interface {
    Bad1
}
\end{Verbatim}

\subsection*{Map types}

A map is an unordered group of elements of one type, called the element
type, indexed by a set of unique \emph{keys} of another type, called the
key type. The value of an uninitialized map is \texttt{nil}.

\begin{Verbatim}[frame=single]
MapType     = "map" "[" KeyType "]" ElementType .
KeyType     = Type .
\end{Verbatim}

The comparison operators \texttt{==} and \texttt{!=} must be fully
defined for operands of the key type; thus the key type must not be a
function, map, or slice. If the key type is an interface type, these
comparison operators must be defined for the dynamic key values; failure
will cause a run-time panic.

\begin{Verbatim}[frame=single]
map[string]int
map[*T]struct{ x, y float64 }
map[string]interface{}
\end{Verbatim}

The number of map elements is called its length. For a map \texttt{m},
it can be discovered using the built-in function
\texttt{len(m)} and may change during
execution. Elements may be added during execution using
assignments and retrieved with
index expressions; they may be removed with the
\texttt{delete} built-in
function.

A new, empty map value is made using the built-in function
\texttt{make}, which
takes the map type and an optional capacity hint as arguments:

\begin{Verbatim}[frame=single]
make(map[string]int)
make(map[string]int, 100)
\end{Verbatim}

The initial capacity does not bound its size: maps grow to accommodate
the number of items stored in them, with the exception of \texttt{nil}
maps. A \texttt{nil} map is equivalent to an empty map except that no
elements may be added.

\subsection*{Channel types}

A channel provides a mechanism for two concurrently executing functions
to synchronize execution and communicate by passing a value of a
specified element type. The value of an uninitialized channel is
\texttt{nil}.

\begin{Verbatim}[frame=single]
ChannelType = ( "chan" [ "<-" ] | "<-" "chan" ) ElementType .
\end{Verbatim}

The \texttt{\textless{}-} operator specifies the channel
\emph{direction}, \emph{send} or \emph{receive}. If no direction is
given, the channel is \emph{bi-directional}. A channel may be
constrained only to send or only to receive by
conversion or
assignment.

\begin{Verbatim}[frame=single]
chan T          // can be used to send and receive values of type T
chan<- float64  // can only be used to send float64s
<-chan int      // can only be used to receive ints
\end{Verbatim}

The \texttt{\textless{}-} operator associates with the leftmost
\texttt{chan} possible:

\begin{Verbatim}[frame=single]
chan<- chan int    // same as chan<- (chan int)
chan<- <-chan int  // same as chan<- (<-chan int)
<-chan <-chan int  // same as <-chan (<-chan int)
chan (<-chan int)
\end{Verbatim}

A new, initialized channel value can be made using the built-in function
\texttt{make}, which
takes the channel type and an optional capacity as arguments:

\begin{Verbatim}[frame=single]
make(chan int, 100)
\end{Verbatim}

The capacity, in number of elements, sets the size of the buffer in the
channel. If the capacity is greater than zero, the channel is
asynchronous: communication operations succeed without blocking if the
buffer is not full (sends) or not empty (receives), and elements are
received in the order they are sent. If the capacity is zero or absent,
the communication succeeds only when both a sender and receiver are
ready. A \texttt{nil} channel is never ready for communication.

A channel may be closed with the built-in function
\texttt{close}; the multi-valued assignment form of
the receive operator tests whether a
channel has been closed.

\section*{Properties of types and values}

\subsection*{Type identity}

Two types are either \emph{identical} or \emph{different}.

Two named types are identical if their type names originate in the same
TypeSpec. A named and an unnamed type are
always different. Two unnamed types are identical if the corresponding
type literals are identical, that is, if they have the same literal
structure and corresponding components have identical types. In detail:

\begin{itemize}
\item
  Two array types are identical if they have identical element types and
  the same array length.
\item
  Two slice types are identical if they have identical element types.
\item
  Two struct types are identical if they have the same sequence of
  fields, and if corresponding fields have the same names, and identical
  types, and identical tags. Two anonymous fields are considered to have
  the same name. Lower-case field names from different packages are
  always different.
\item
  Two pointer types are identical if they have identical base types.
\item
  Two function types are identical if they have the same number of
  parameters and result values, corresponding parameter and result types
  are identical, and either both functions are variadic or neither is.
  Parameter and result names are not required to match.
\item
  Two interface types are identical if they have the same set of methods
  with the same names and identical function types. Lower-case method
  names from different packages are always different. The order of the
  methods is irrelevant.
\item
  Two map types are identical if they have identical key and value
  types.
\item
  Two channel types are identical if they have identical value types and
  the same direction.
\end{itemize}

Given the declarations

\begin{Verbatim}[frame=single]
type (
    T0 []string
    T1 []string
    T2 struct{ a, b int }
    T3 struct{ a, c int }
    T4 func(int, float64) *T0
    T5 func(x int, y float64) *[]string
)
\end{Verbatim}

these types are identical:

\begin{Verbatim}[frame=single]
T0 and T0
[]int and []int
struct{ a, b *T5 } and struct{ a, b *T5 }
func(x int, y float64) *[]string and func(int, float64) (result *[]string)
\end{Verbatim}

\texttt{T0} and \texttt{T1} are different because they are named types
with distinct declarations; \texttt{func(int, float64) *T0} and
\texttt{func(x int, y float64) *{[}{]}string} are different because
\texttt{T0} is different from \texttt{{[}{]}string}.

\subsection*{Assignability}

A value \texttt{x} is \emph{assignable} to a variable of type \texttt{T}
("\texttt{x} is assignable to \texttt{T}") in any of these cases:

\begin{itemize}
\item
  \texttt{x}'s type is identical to \texttt{T}.
\item
  \texttt{x}'s type \texttt{V} and \texttt{T} have identical
  underlying types and at least one of \texttt{V} or
  \texttt{T} is not a named type.
\item
  \texttt{T} is an interface type and \texttt{x}
  implements \texttt{T}.
\item
  \texttt{x} is a bidirectional channel value, \texttt{T} is a channel
  type, \texttt{x}'s type \texttt{V} and \texttt{T} have identical
  element types, and at least one of \texttt{V} or \texttt{T} is not a
  named type.
\item
  \texttt{x} is the predeclared identifier \texttt{nil} and \texttt{T}
  is a pointer, function, slice, map, channel, or interface type.
\item
  \texttt{x} is an untyped constant representable
  by a value of type \texttt{T}.
\end{itemize}

Any value may be assigned to the blank identifier.

\section*{Blocks}

A \emph{block} is a sequence of declarations and statements within
matching brace brackets.

\begin{Verbatim}[frame=single]
Block = "{" { Statement ";" } "}" .
\end{Verbatim}

In addition to explicit blocks in the source code, there are implicit
blocks:

\begin{enumerate}
\item
  The \emph{universe block} encompasses all Go source text.
\item
  Each package has a \emph{package} block
  containing all Go source text for that package.
\item
  Each file has a \emph{file block} containing all Go source text in
  that file.
\item
  Each \texttt{if}, \texttt{for}, and \texttt{switch} statement is
  considered to be in its own implicit block.
\item
  Each clause in a \texttt{switch} or \texttt{select} statement acts as
  an implicit block.
\end{enumerate}

Blocks nest and influence scoping.

\section*{Declarations and scope}

A declaration binds a non-blank identifier
to a constant, type, variable, function, or package. Every identifier in
a program must be declared. No identifier may be declared twice in the
same block, and no identifier may be declared in both the file and
package block.

\begin{Verbatim}[frame=single]
Declaration   = ConstDecl | TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
\end{Verbatim}

The \emph{scope} of a declared identifier is the extent of source text
in which the identifier denotes the specified constant, type, variable,
function, or package.

Go is lexically scoped using blocks:

\begin{enumerate}
\item
  The scope of a predeclared identifier is the universe block.
\item
  The scope of an identifier denoting a constant, type, variable, or
  function (but not method) declared at top level (outside any function)
  is the package block.
\item
  The scope of an imported package identifier is the file block of the
  file containing the import declaration.
\item
  The scope of an identifier denoting a function parameter or result
  variable is the function body.
\item
  The scope of a constant or variable identifier declared inside a
  function begins at the end of the ConstSpec or VarSpec (ShortVarDecl
  for short variable declarations) and ends at the end of the innermost
  containing block.
\item
  The scope of a type identifier declared inside a function begins at
  the identifier in the TypeSpec and ends at the end of the innermost
  containing block.
\end{enumerate}

An identifier declared in a block may be redeclared in an inner block.
While the identifier of the inner declaration is in scope, it denotes
the entity declared by the inner declaration.

The package clause is not a declaration; the
package name does not appear in any scope. Its purpose is to identify
the files belonging to the same package and to
specify the default package name for import declarations.

\subsection*{Label scopes}

Labels are declared by labeled statements and are used in the
\texttt{break}, \texttt{continue}, and \texttt{goto} statements
(\texttt{break} statements, \texttt{continue} statements,
\texttt{goto} statements). It is illegal to define a label that is never
used. In contrast to other identifiers, labels are not block scoped
and do not conflict with identifiers that are not labels. The scope
of a label is the body of the function in which it is declared and
excludes the body of any nested function.

\subsection*{Blank identifier}

The \emph{blank identifier}, represented by the underscore character
\texttt{\_}, may be used in a declaration like any other identifier but
the declaration does not introduce a new binding.

\subsection*{Predeclared identifiers}

The following identifiers are implicitly declared in the
universe block:

\begin{Verbatim}[frame=single]
Types:
    bool byte complex64 complex128 error float32 float64
    int int8 int16 int32 int64 rune string
    uint uint8 uint16 uint32 uint64 uintptr

Constants:
    true false iota

Zero value:
    nil

Functions:
    append cap close complex copy delete imag len
    make new panic print println real recover
\end{Verbatim}

\subsection*{Exported identifiers}

An identifier may be \emph{exported} to permit access to it from another
package. An identifier is exported if both:

\begin{enumerate}
\item
  the first character of the identifier's name is a Unicode upper case
  letter (Unicode class ``Lu''); and
\item
  the identifier is declared in the package block or
  it is a field name or
  method name.
\end{enumerate}

All other identifiers are not exported.

\subsection*{Uniqueness of identifiers}

Given a set of identifiers, an identifier is called \emph{unique} if it
is \emph{different} from every other in the set. Two identifiers are
different if they are spelled differently, or if they appear in
different packages and are not
exported. Otherwise, they are the
same.

\subsection*{Constant declarations}

A constant declaration binds a list of identifiers (the names of the
constants) to the values of a list of
constant expressions. The number of
identifiers must be equal to the number of expressions, and the
\emph{n}th identifier on the left is bound to the value of the
\emph{n}th expression on the right.

\begin{Verbatim}[frame=single]
ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .

IdentifierList = identifier { "," identifier } .
ExpressionList = Expression { "," Expression } .
\end{Verbatim}

If the type is present, all constants take the type specified, and the
expressions must be assignable to that type.
If the type is omitted, the constants take the individual types of the
corresponding expressions. If the expression values are untyped
constants, the declared constants remain untyped
and the constant identifiers denote the constant values. For instance,
if the expression is a floating-point literal, the constant identifier
denotes a floating-point constant, even if the literal's fractional part
is zero.

\begin{Verbatim}[frame=single]
const Pi float64 = 3.14159265358979323846
const zero = 0.0         // untyped floating-point constant
const (
    size int64 = 1024
    eof        = -1  // untyped integer constant
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", untyped integer and string constants
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
\end{Verbatim}

Within a parenthesized \texttt{const} declaration list the expression
list may be omitted from any but the first declaration. Such an empty
list is equivalent to the textual substitution of the first preceding
non-empty expression list and its type if any. Omitting the list of
expressions is therefore equivalent to repeating the previous list. The
number of identifiers must be equal to the number of expressions in the
previous list. Together with the \texttt{iota constant
generator} this mechanism permits light-weight declaration of sequential
values:

\begin{Verbatim}[frame=single]
const (
    Sunday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Partyday
    numberOfDays  // this constant is not exported
)
\end{Verbatim}

\subsection*{Iota}

Within a constant declaration, the
predeclared identifier \texttt{iota} represents successive untyped
integer constants. It is reset to 0 whenever the
reserved word \texttt{const} appears in the source and increments after
each ConstSpec. It can be used to construct a set
of related constants:

\begin{Verbatim}[frame=single]
const (  // iota is reset to 0
    c0 = iota  // c0 == 0
    c1 = iota  // c1 == 1
    c2 = iota  // c2 == 2
)

const (
    a = 1 << iota  // a == 1 (iota has been reset)
    b = 1 << iota  // b == 2
    c = 1 << iota  // c == 4
)

const (
    u         = iota * 42  // u == 0     (untyped integer constant)
    v float64 = iota * 42  // v == 42.0  (float64 constant)
    w         = iota * 42  // w == 84    (untyped integer constant)
)

const x = iota  // x == 0 (iota has been reset)
const y = iota  // y == 0 (iota has been reset)
\end{Verbatim}

Within an ExpressionList, the value of each \texttt{iota} is the same
because it is only incremented after each ConstSpec:

\begin{Verbatim}[frame=single]
const (
    bit0, mask0 = 1 << iota, 1<<iota - 1  // bit0 == 1, mask0 == 0
    bit1, mask1                           // bit1 == 2, mask1 == 1
    _, _                                  // skips iota == 2
    bit3, mask3                           // bit3 == 8, mask3 == 7
)
\end{Verbatim}

This last example exploits the implicit repetition of the last non-empty
expression list.

\subsection*{Type declarations}

A type declaration binds an identifier, the \emph{type name}, to a new
type that has the same underlying type as an existing
type. The new type is different from the
existing type.

\begin{Verbatim}[frame=single]
TypeDecl     = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
TypeSpec     = identifier Type .
\end{Verbatim}

\begin{Verbatim}[frame=single]
type IntArray [16]int

type (
    Point struct{ x, y float64 }
    Polar Point
)

type TreeNode struct {
    left, right *TreeNode
    value *Comparable
}

type Block interface {
    BlockSize() int
    Encrypt(src, dst []byte)
    Decrypt(src, dst []byte)
}
\end{Verbatim}

The declared type does not inherit any
methods bound to the existing type, but
the method set of an interface type or of
elements of a composite type remains unchanged:

\begin{Verbatim}[frame=single]
// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock implementation */ }
func (m *Mutex) Unlock()  { /* Unlock implementation */ }

// NewMutex has the same composition as Mutex but its method set is empty.
type NewMutex Mutex

// The method set of the base type of PtrMutex remains unchanged,
// but the method set of PtrMutex is empty.
type PtrMutex *Mutex

// The method set of *PrintableMutex contains the methods
// Lock and Unlock bound to its anonymous field Mutex.
type PrintableMutex struct {
    Mutex
}

// MyBlock is an interface type that has the same method set as Block.
type MyBlock Block
\end{Verbatim}

A type declaration may be used to define a different boolean, numeric,
or string type and attach methods to it:

\begin{Verbatim}[frame=single]
type TimeZone int

const (
    EST TimeZone = -(5 + iota)
    CST
    MST
    PST
)

func (tz TimeZone) String() string {
    return fmt.Sprintf("GMT+%dh", tz)
}
\end{Verbatim}

\subsection*{Variable declarations}

A variable declaration creates a variable, binds an identifier to it and
gives it a type and optionally an initial value.

\begin{Verbatim}[frame=single]
VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
\end{Verbatim}

\begin{Verbatim}[frame=single]
var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
    i       int
    u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // map lookup; only interested in "found"
\end{Verbatim}

If a list of expressions is given, the variables are initialized
by assigning the expressions to the variables in order; all expressions
must be consumed and all variables initialized from them. Otherwise,
each variable is initialized to its zero value.

If the type is present, each variable is given that type. Otherwise, the
types are deduced from the assignment of the expression list.

If the type is absent and the corresponding expression evaluates to an
untyped constant, the type of the declared
variable is as described in Assignments.

Implementation restriction: A compiler may make it illegal to declare a
variable inside a function body if
the variable is never used.

\subsection*{Short variable declarations}

A \emph{short variable declaration} uses the syntax:

\begin{Verbatim}[frame=single]
ShortVarDecl = IdentifierList ":=" ExpressionList .
\end{Verbatim}

It is a shorthand for a regular
variable declaration with initializer
expressions but no types:

\begin{Verbatim}[frame=single]
"var" IdentifierList = ExpressionList .
\end{Verbatim}

\begin{Verbatim}[frame=single]
i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w := os.Pipe(fd)  // os.Pipe() returns two values
_, y, _ := coord(p)  // coord() returns three values; only interested in y coordinate
\end{Verbatim}

Unlike regular variable declarations, a short variable declaration may
redeclare variables provided they were originally declared in the same
block with the same type, and at least one of the
non-blank variables is new. As a
consequence, redeclaration can only appear in a multi-variable short
declaration. Redeclaration does not introduce a new variable; it just
assigns a new value to the original.

\begin{Verbatim}[frame=single]
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // redeclares offset
\end{Verbatim}

Short variable declarations may appear only inside functions. In some
contexts such as the initializers for \texttt{if}, \texttt{for}, or
\texttt{switch} statements, they can be used to declare local temporary
variables.

\subsection*{Function declarations}

A function declaration binds an identifier, the \emph{function name}, to
a function.

\begin{Verbatim}[frame=single]
FunctionDecl = "func" FunctionName Signature [ Body ] .
FunctionName = identifier .
Body         = Block .
\end{Verbatim}

A function declaration may omit the body. Such a declaration provides
the signature for a function implemented outside Go, such as an assembly
routine.

\begin{Verbatim}[frame=single]
func min(x int, y int) int {
    if x < y {
        return x
    }
    return y
}

func flushICache(begin, end uintptr)  // implemented externally
\end{Verbatim}

\subsection*{Method declarations}

A method is a function with a \emph{receiver}. A method declaration
binds an identifier, the \emph{method name}, to a method. It also
associates the method with the receiver's \emph{base type}.

\begin{Verbatim}[frame=single]
MethodDecl   = "func" Receiver MethodName Signature [ Body ] .
Receiver     = "(" [ identifier ] [ "*" ] BaseTypeName ")" .
BaseTypeName = identifier .
\end{Verbatim}

The receiver type must be of the form \texttt{T} or \texttt{*T} where
\texttt{T} is a type name. The type denoted by \texttt{T} is called the
receiver \emph{base type}; it must not be a pointer or interface type
and it must be declared in the same package as the method. The method is
said to be \emph{bound} to the base type and the method name is visible
only within selectors for that type.

For a base type, the non-blank names of
methods bound to it must be
unique. If the base type is a
struct type, the non-blank method and field
names must be distinct.

Given type \texttt{Point}, the declarations

\begin{Verbatim}[frame=single]
func (p *Point) Length() float64 {
    return math.Sqrt(p.x * p.x + p.y * p.y)
}

func (p *Point) Scale(factor float64) {
    p.x *= factor
    p.y *= factor
}
\end{Verbatim}

bind the methods \texttt{Length} and \texttt{Scale}, with receiver type
\texttt{*Point}, to the base type \texttt{Point}.

If the receiver's value is not referenced inside the body of the method,
its identifier may be omitted in the declaration. The same applies in
general to parameters of functions and methods.

The type of a method is the type of a function with the receiver as
first argument. For instance, the method \texttt{Scale} has type

\begin{Verbatim}[frame=single]
func(p *Point, factor float64)
\end{Verbatim}

However, a function declared this way is not a method.

\section*{Expressions}

An expression specifies the computation of a value by applying operators
and functions to operands.

\subsection*{Operands}

Operands denote the elementary values in an expression. An operand may
be a literal, a (possibly qualified)
identifier denoting a constant,
variable, or
function, a
method expression yielding a function,
or a parenthesized expression.

\begin{Verbatim}[frame=single]
Operand    = Literal | OperandName | MethodExpr | "(" Expression ")" .
Literal    = BasicLit | CompositeLit | FunctionLit .
BasicLit   = int_lit | float_lit | imaginary_lit | char_lit | string_lit .
OperandName = identifier | QualifiedIdent.
\end{Verbatim}

\subsection*{Qualified identifiers}

A qualified identifier is an identifier qualified with a package name
prefix. Both the package name and the identifier must not be
blank.

\begin{Verbatim}[frame=single]
QualifiedIdent = PackageName "." identifier .
\end{Verbatim}

A qualified identifier accesses an identifier in a different package,
which must be imported. The identifier
must be exported and declared in the
package block of that package.

\begin{Verbatim}[frame=single]
math.Sin    // denotes the Sin function in package math
\end{Verbatim}

\subsection*{Composite literals}

Composite literals construct values for structs, arrays, slices, and
maps and create a new value each time they are evaluated. They consist
of the type of the value followed by a brace-bound list of composite
elements. An element may be a single expression or a key-value pair.

\begin{Verbatim}[frame=single]
CompositeLit  = LiteralType LiteralValue .
LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |
                SliceType | MapType | TypeName .
LiteralValue  = "{" [ ElementList [ "," ] ] "}" .
ElementList   = Element { "," Element } .
Element       = [ Key ":" ] Value .
Key           = FieldName | ElementIndex .
FieldName     = identifier .
ElementIndex  = Expression .
Value         = Expression | LiteralValue .
\end{Verbatim}

The LiteralType must be a struct, array, slice, or map type (the grammar
enforces this constraint except when the type is given as a TypeName).
The types of the expressions must be
assignable to the respective field, element,
and key types of the LiteralType; there is no additional conversion. The
key is interpreted as a field name for struct literals, an index
expression for array and slice literals, and a key for map literals. For
map literals, all elements must have a key. It is an error to specify
multiple elements with the same field name or constant key value.

For struct literals the following rules apply:

\begin{itemize}
\item
  A key must be a field name declared in the LiteralType.
\item
  A literal that does not contain any keys must list an element for each
  struct field in the order in which the fields are declared.
\item
  If any element has a key, every element must have a key.
\item
  A literal that contains keys does not need to have an element for each
  struct field. Omitted fields get the zero value for that field.
\item
  A literal may omit the element list; such a literal evaluates to the
  zero value for its type.
\item
  It is an error to specify an element for a non-exported field of a
  struct belonging to a different package.
\end{itemize}

Given the declarations

\begin{Verbatim}[frame=single]
type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }
\end{Verbatim}

one may write

\begin{Verbatim}[frame=single]
origin := Point3D{}                            // zero value for Point3D
line := Line{origin, Point3D{y: -4, z: 12.3}}  // zero value for line.q.x
\end{Verbatim}

For array and slice literals the following rules apply:

\begin{itemize}
\item
  Each element has an associated integer index marking its position in
  the array.
\item
  An element with a key uses the key as its index; the key must be a
  constant integer expression.
\item
  An element without a key uses the previous element's index plus one.
  If the first element has no key, its index is zero.
\end{itemize}

Taking the address of a composite literal generates a pointer to a
unique instance of the literal's value.

\begin{Verbatim}[frame=single]
var pointer *Point3D = &Point3D{y: 1000}
\end{Verbatim}

The length of an array literal is the length specified in the
LiteralType. If fewer elements than the length are provided in the
literal, the missing elements are set to the zero value for the array
element type. It is an error to provide elements with index values
outside the index range of the array. The notation \texttt{...}
specifies an array length equal to the maximum element index plus one.

\begin{Verbatim}[frame=single]
buffer := [10]string{}             // len(buffer) == 10
intSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6
days := [...]string{"Sat", "Sun"}  // len(days) == 2
\end{Verbatim}

A slice literal describes the entire underlying array literal. Thus, the
length and capacity of a slice literal are the maximum element index
plus one. A slice literal has the form

\begin{Verbatim}[frame=single]
[]T{x1, x2, … xn}
\end{Verbatim}

and is a shortcut for a slice operation applied to an array:

\begin{Verbatim}[frame=single]
tmp := [n]T{x1, x2, … xn}
tmp[0 : n]
\end{Verbatim}

Within a composite literal of array, slice, or map type \texttt{T},
elements that are themselves composite literals may elide the respective
literal type if it is identical to the element type of \texttt{T}.
Similarly, elements that are addresses of composite literals may elide
the \texttt{\&T} when the element type is \texttt{*T}.

\begin{Verbatim}[frame=single]
[...]Point{{1.5, -3.5}, {0, 0}}   // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}        // same as [][]int{[]int{1, 2, 3}, []int{4, 5}}

[...]*Point{{1.5, -3.5}, {0, 0}}  // same as [...]*Point{&Point{1.5, -3.5}, &Point{0, 0}}
\end{Verbatim}

A parsing ambiguity arises when a composite literal using the TypeName
form of the LiteralType appears between the keyword
and the opening brace of the block of an ``if'', ``for'', or ``switch''
statement, because the braces surrounding the expressions in the literal
are confused with those introducing the block of statements. To resolve
the ambiguity in this rare case, the composite literal must appear
within parentheses.

\begin{Verbatim}[frame=single]
if x == (T{a,b,c}[i]) { … }
if (x == T{a,b,c}[i]) { … }
\end{Verbatim}

Examples of valid array, slice, and map literals:

\begin{Verbatim}[frame=single]
// list of prime numbers
primes := []int{2, 3, 5, 7, 9, 2147483647}

// vowels[ch] is true if ch is a vowel
vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}

// the array [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}
filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}

// frequencies in Hz for equal-tempered scale (A4 = 440Hz)
noteFrequency := map[string]float32{
    "C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
    "G0": 24.50, "A0": 27.50, "B0": 30.87,
}
\end{Verbatim}

\subsection*{Function literals}

A function literal represents an anonymous function. It consists of a
specification of the function type and a function body.

\begin{Verbatim}[frame=single]
FunctionLit = FunctionType Body .
\end{Verbatim}

\begin{Verbatim}[frame=single]
func(a, b int, z float64) bool { return a*b < int(z) }
\end{Verbatim}

A function literal can be assigned to a variable or invoked directly.

\begin{Verbatim}[frame=single]
f := func(x, y int) int { return x + y }
func(ch chan int) { ch <- ACK }(replyChan)
\end{Verbatim}

Function literals are \emph{closures}: they may refer to variables
defined in a surrounding function. Those variables are then shared
between the surrounding function and the function literal, and they
survive as long as they are accessible.

\subsection*{Primary expressions}

Primary expressions are the operands for unary and binary expressions.

\begin{Verbatim}[frame=single]
PrimaryExpr =
    Operand |
    Conversion |
    BuiltinCall |
    PrimaryExpr Selector |
    PrimaryExpr Index |
    PrimaryExpr Slice |
    PrimaryExpr TypeAssertion |
    PrimaryExpr Call .

Selector       = "." identifier .
Index          = "[" Expression "]" .
Slice          = "[" [ Expression ] ":" [ Expression ] "]" .
TypeAssertion  = "." "(" Type ")" .
Call           = "(" [ ArgumentList [ "," ] ] ")" .
ArgumentList   = ExpressionList [ "..." ] .
\end{Verbatim}

\begin{Verbatim}[frame=single]
x
2
(s + ".txt")
f(3.1415, true)
Point{1, 2}
m["foo"]
s[i : j + 1]
obj.color
f.p[i].x()
\end{Verbatim}

\subsection*{Selectors}

For a primary expression \texttt{x}
that is not a package name, the
\emph{selector expression}

\begin{Verbatim}[frame=single]
x.f
\end{Verbatim}

denotes the field or method \texttt{f} of the value \texttt{x} (or
sometimes \texttt{*x}; see below). The identifier \texttt{f} is called
the (field or method) \emph{selector}; it must not be the
blank identifier. The type of the selector
expression is the type of \texttt{f}. If \texttt{x} is a package name,
see the section on qualified identifiers.

A selector \texttt{f} may denote a field or method \texttt{f} of a type
\texttt{T}, or it may refer to a field or method \texttt{f} of a nested
anonymous field of \texttt{T}. The number of
anonymous fields traversed to reach \texttt{f} is called its
\emph{depth} in \texttt{T}. The depth of a field or method \texttt{f}
declared in \texttt{T} is zero. The depth of a field or method
\texttt{f} declared in an anonymous field \texttt{A} in \texttt{T} is
the depth of \texttt{f} in \texttt{A} plus one.

The following rules apply to selectors:

\begin{enumerate}
\item
  For a value \texttt{x} of type \texttt{T} or \texttt{*T} where
  \texttt{T} is not an interface type, \texttt{x.f} denotes the field or
  method at the shallowest depth in \texttt{T} where there is such an
  \texttt{f}. If there is not exactly
  one \texttt{f} with shallowest
  depth, the selector expression is illegal.
\item
  For a variable \texttt{x} of type \texttt{I} where \texttt{I} is an
  interface type, \texttt{x.f} denotes the actual method with name
  \texttt{f} of the value assigned to \texttt{x}. If there is no method
  with name \texttt{f} in the method set of
  \texttt{I}, the selector expression is illegal.
\item
  In all other cases, \texttt{x.f} is illegal.
\item
  If \texttt{x} is of pointer or interface type and has the value
  \texttt{nil}, assigning to, evaluating, or calling \texttt{x.f} causes
  a run-time panic.
\end{enumerate}

Selectors automatically dereference
pointers to structs. If \texttt{x} is a pointer to a struct,
\texttt{x.y} is shorthand for \texttt{(*x).y}; if the field \texttt{y}
is also a pointer to a struct, \texttt{x.y.z} is shorthand for
\texttt{(*(*x).y).z}, and so on. If \texttt{x} contains an anonymous
field of type \texttt{*A}, where \texttt{A} is also a struct type,
\texttt{x.f} is a shortcut for \texttt{(*x.A).f}.

For example, given the declarations:

\begin{Verbatim}[frame=single]
type T0 struct {
    x int
}

func (recv *T0) M0()

type T1 struct {
    y int
}

func (recv T1) M1()

type T2 struct {
    z int
    T1
    *T0
}

func (recv *T2) M2()

var p *T2  // with p != nil and p.T0 != nil
\end{Verbatim}

one may write:

\begin{Verbatim}[frame=single]
p.z   // (*p).z
p.y   // ((*p).T1).y
p.x   // (*(*p).T0).x

p.M2  // (*p).M2
p.M1  // ((*p).T1).M1
p.M0  // ((*p).T0).M0
\end{Verbatim}

\subsection*{Indexes}

A primary expression of the form

\begin{Verbatim}[frame=single]
a[x]
\end{Verbatim}

denotes the element of the array, slice, string or map \texttt{a}
indexed by \texttt{x}. The value \texttt{x} is called the \emph{index}
or \emph{map key}, respectively. The following rules apply:

For \texttt{a} of type \texttt{A} or \texttt{*A} where \texttt{A} is an
array type, or for \texttt{a} of type
\texttt{S} where \texttt{S} is a slice type:

\begin{itemize}
\item
  \texttt{x} must be an integer value and
  \texttt{0 \textless{}= x \textless{} len(a)}
\item
  \texttt{a{[}x{]}} is the array element at index \texttt{x} and the
  type of \texttt{a{[}x{]}} is the element type of \texttt{A}
\item
  if \texttt{a} is \texttt{nil} or if the index \texttt{x} is out of
  range, a run-time panic occurs
\end{itemize}

For \texttt{a} of type \texttt{T} where \texttt{T} is a
string type:

\begin{itemize}
\item
  \texttt{x} must be an integer value and
  \texttt{0 \textless{}= x \textless{} len(a)}
\item
  \texttt{a{[}x{]}} is the byte at index \texttt{x} and the type of
  \texttt{a{[}x{]}} is \texttt{byte}
\item
  \texttt{a{[}x{]}} may not be assigned to
\item
  if the index \texttt{x} is out of range, a
  run-time panic occurs
\end{itemize}

For \texttt{a} of type \texttt{M} where \texttt{M} is a
map type:

\begin{itemize}
\item
  \texttt{x}'s type must be assignable to the
  key type of \texttt{M}
\item
  if the map contains an entry with key \texttt{x}, \texttt{a{[}x{]}} is
  the map value with key \texttt{x} and the type of \texttt{a{[}x{]}} is
  the value type of \texttt{M}
\item
  if the map is \texttt{nil} or does not contain such an entry,
  \texttt{a{[}x{]}} is the zero value for
  the value type of \texttt{M}
\end{itemize}

Otherwise \texttt{a{[}x{]}} is illegal.

An index expression on a map \texttt{a} of type \texttt{map{[}K{]}V} may
be used in an assignment or initialization of the special form

\begin{Verbatim}[frame=single]
v, ok = a[x]
v, ok := a[x]
var v, ok = a[x]
\end{Verbatim}

where the result of the index expression is a pair of values with types
\texttt{(V, bool)}. In this form, the value of \texttt{ok} is
\texttt{true} if the key \texttt{x} is present in the map, and
\texttt{false} otherwise. The value of \texttt{v} is the value
\texttt{a{[}x{]}} as in the single-result form.

Assigning to an element of a \texttt{nil} map causes a
run-time panic.

\subsection*{Slices}

For a string, array, pointer to array, or slice \texttt{a}, the primary
expression

\begin{Verbatim}[frame=single]
a[low : high]
\end{Verbatim}

constructs a substring or slice. The index expressions \texttt{low} and
\texttt{high} select which elements appear in the result. The result has
indexes starting at 0 and length equal to \texttt{high}~-~\texttt{low}.
After slicing the array \texttt{a}

\begin{Verbatim}[frame=single]
a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]
\end{Verbatim}

the slice \texttt{s} has type \texttt{{[}{]}int}, length 3, capacity 4,
and elements

\begin{Verbatim}[frame=single]
s[0] == 2
s[1] == 3
s[2] == 4
\end{Verbatim}

For convenience, any of the index expressions may be omitted. A missing
\texttt{low} index defaults to zero; a missing \texttt{high} index
defaults to the length of the sliced operand:

\begin{Verbatim}[frame=single]
a[2:]  // same a[2 : len(a)]
a[:3]  // same as a[0 : 3]
a[:]   // same as a[0 : len(a)]
\end{Verbatim}

For arrays or strings, the indexes \texttt{low} and \texttt{high} must
satisfy 0 \textless{}= \texttt{low} \textless{}= \texttt{high}
\textless{}= length; for slices, the upper bound is the capacity rather
than the length.

If the sliced operand is a string or slice, the result of the slice
operation is a string or slice of the same type. If the sliced operand
is an array, it must be addressable and
the result of the slice operation is a slice with the same element type
as the array.

\subsection*{Type assertions}

For an expression \texttt{x} of interface type and a type \texttt{T},
the primary expression

\begin{Verbatim}[frame=single]
x.(T)
\end{Verbatim}

asserts that \texttt{x} is not \texttt{nil} and that the value stored in
\texttt{x} is of type \texttt{T}. The notation \texttt{x.(T)} is called
a \emph{type assertion}.

More precisely, if \texttt{T} is not an interface type, \texttt{x.(T)}
asserts that the dynamic type of \texttt{x} is identical to the
type \texttt{T}. If \texttt{T} is an interface type, \texttt{x.(T)}
asserts that the dynamic type of \texttt{x} implements the interface
\texttt{T}.

If the type assertion holds, the value of the expression is the value
stored in \texttt{x} and its type is \texttt{T}. If the type assertion
is false, a run-time panic occurs. In
other words, even though the dynamic type of \texttt{x} is known only at
run-time, the type of \texttt{x.(T)} is known to be \texttt{T} in a
correct program.

If a type assertion is used in an assignment or initialization of the
form

\begin{Verbatim}[frame=single]
v, ok = x.(T)
v, ok := x.(T)
var v, ok = x.(T)
\end{Verbatim}

the result of the assertion is a pair of values with types \texttt{(T,
bool)}. If the assertion holds, the expression returns the pair
\texttt{(x.(T), true)}; otherwise, the expression returns \texttt{(Z,
false)} where \texttt{Z} is the zero value for type \texttt{T}. No
run-time panic occurs in this case. The type assertion in this
construct thus acts like a function call returning a value and a
boolean indicating success.

\subsection*{Calls}

Given an expression \texttt{f} of function type \texttt{F},

\begin{Verbatim}[frame=single]
f(a1, a2, … an)
\end{Verbatim}

calls \texttt{f} with arguments \texttt{a1, a2, \ldots{} an}. Except for
one special case, arguments must be single-valued expressions
assignable to the parameter types of
\texttt{F} and are evaluated before the function is called. The type of
the expression is the result type of \texttt{F}. A method invocation is
similar but the method itself is specified as a selector upon a value of
the receiver type for the method.

\begin{Verbatim}[frame=single]
math.Atan2(x, y)  // function call
var pt *Point
pt.Scale(3.5)  // method call with receiver pt
\end{Verbatim}

In a function call, the function value and arguments are evaluated in
the usual order. After they are
evaluated, the parameters of the call are passed by value to the
function and the called function begins execution. The return parameters
of the function are passed by value back to the calling function when
the function returns.

Calling a \texttt{nil} function value causes a
run-time panic.

As a special case, if the return parameters of a function or method
\texttt{g} are equal in number and individually assignable to the
parameters of another function or method \texttt{f}, then the call
\texttt{f(g(parameters\_of\_g))} will invoke \texttt{f} after binding
the return values of \texttt{g} to the parameters of \texttt{f} in
order. The call of \texttt{f} must contain no parameters other than the
call of \texttt{g}. If \texttt{f} has a final \texttt{...} parameter, it
is assigned the return values of \texttt{g} that remain after assignment
of regular parameters.

\begin{Verbatim}[frame=single]
func Split(s string, pos int) (string, string) {
    return s[0:pos], s[pos:]
}

func Join(s, t string) string {
    return s + t
}

if Join(Split(value, len(value)/2)) != value {
    log.Panic("test fails")
}
\end{Verbatim}

A method call \texttt{x.m()} is valid if the
method set of (the type of) \texttt{x} contains
\texttt{m} and the argument list can be assigned to the parameter list
of \texttt{m}. If \texttt{x} is
addressable and \texttt{\&x}'s method set
contains \texttt{m}, \texttt{x.m()} is shorthand for \texttt{(\&x).m()}:

\begin{Verbatim}[frame=single]
var p Point
p.Scale(3.5)
\end{Verbatim}

There is no distinct method type and there are no method literals.

\subsection*{Passing arguments to \texttt{...} parameters}

If \texttt{f} is variadic with final parameter type \texttt{...T}, then
within the function the argument is equivalent to a parameter of type
\texttt{{[}{]}T}. At each call of \texttt{f}, the argument passed to the
final parameter is a new slice of type \texttt{{[}{]}T} whose successive
elements are the actual arguments, which all must be
assignable to the type \texttt{T}. The length
of the slice is therefore the number of arguments bound to the final
parameter and may differ for each call site.

Given the function and call

\begin{Verbatim}[frame=single]
func Greeting(prefix string, who ...string)
Greeting("hello:", "Joe", "Anna", "Eileen")
\end{Verbatim}

within \texttt{Greeting}, \texttt{who} will have the value
\texttt{{[}{]}string\{"Joe", "Anna", "Eileen"\}}

If the final argument is assignable to a slice type \texttt{{[}{]}T}, it
may be passed unchanged as the value for a \texttt{...T} parameter if
the argument is followed by \texttt{...}. In this case no new slice is
created.

Given the slice \texttt{s} and call

\begin{Verbatim}[frame=single]
s := []string{"James", "Jasmine"}
Greeting("goodbye:", s...)
\end{Verbatim}

within \texttt{Greeting}, \texttt{who} will have the same value as
\texttt{s} with the same underlying array.

\subsection*{Operators}

Operators combine operands into expressions.

\begin{Verbatim}[frame=single]
Expression = UnaryExpr | Expression binary_op UnaryExpr .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = "||" | "&&" | rel_op | add_op | mul_op .
rel_op     = "==" | "!=" | "<" | "<=" | ">" | ">=" .
add_op     = "+" | "-" | "|" | "^" .
mul_op     = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .

unary_op   = "+" | "-" | "!" | "^" | "*" | "&" | "<-" .
\end{Verbatim}

Comparisons are discussed elsewhere.
For other binary operators, the operand types must be
identical unless the operation involves
shifts or untyped constants. For operations
involving constants only, see the section on
constant expressions.

Except for shift operations, if one operand is an untyped
constant and the other operand is not, the
constant is converted to the type of the other
operand.

The right operand in a shift expression must have unsigned integer type
or be an untyped constant that can be converted to unsigned integer
type. If the left operand of a non-constant shift expression is an
untyped constant, the type of the constant is what it would be if the
shift expression were replaced by its left operand alone; the type is
\texttt{int} if it cannot be determined from the context (for instance,
if the shift expression is an operand in a comparison against an untyped
constant).

\begin{Verbatim}[frame=single]
var s uint = 33
var i = 1<<s           // 1 has type int
var j int32 = 1<<s     // 1 has type int32; j == 0
var k = uint64(1<<s)   // 1 has type uint64; k == 1<<33
var m int = 1.0<<s     // 1.0 has type int
var n = 1.0<<s != 0    // 1.0 has type int; n == false if ints are 32bits in size
var o = 1<<s == 2<<s   // 1 and 2 have type int; o == true if ints are 32bits in size
var p = 1<<s == 1<<33  // illegal if ints are 32bits in size: 1 has type int, but 1<<33 overflows int
var u = 1.0<<s         // illegal: 1.0 has type float64, cannot shift
var v float32 = 1<<s   // illegal: 1 has type float32, cannot shift
var w int64 = 1.0<<33  // 1.0<<33 is a constant shift expression
\end{Verbatim}

\subsection*{Operator precedence}

Unary operators have the highest precedence. As the \texttt{++} and
\texttt{-{}-} operators form statements, not expressions, they fall
outside the operator hierarchy. As a consequence, statement
\texttt{*p++} is the same as \texttt{(*p)++}.

There are five precedence levels for binary operators. Multiplication
operators bind strongest, followed by addition operators, comparison
operators, \texttt{\&\&} (logical and), and finally
\texttt{\textbar{}\textbar{}} (logical or):

\begin{Verbatim}[frame=single]
Precedence    Operator
    5             *  /  %  <<  >>  &  &^
    4             +  -  |  ^
    3             ==  !=  <  <=  >  >=
    2             &&
    1             ||
\end{Verbatim}

Binary operators of the same precedence associate from left to right.
For instance, \texttt{x / y * z} is the same as \texttt{(x / y) * z}.

\begin{Verbatim}[frame=single]
+x
23 + 3*x[i]
x <= f()
^a >> b
f() || g()
x == y+1 && <-chanPtr > 0
\end{Verbatim}

\subsection*{Arithmetic operators}

Arithmetic operators apply to numeric values and yield a result of the
same type as the first operand. The four standard arithmetic operators
(\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}) apply to integer,
floating-point, and complex types; \texttt{+} also applies to strings.
All other arithmetic operators apply to integers only.

\begin{Verbatim}[frame=single]
+    sum                    integers, floats, complex values, strings
-    difference             integers, floats, complex values
*    product                integers, floats, complex values
/    quotient               integers, floats, complex values
%    remainder              integers

&    bitwise and            integers
|    bitwise or             integers
^    bitwise xor            integers
&^   bit clear (and not)    integers

<<   left shift             integer << unsigned integer
>>   right shift            integer >> unsigned integer
\end{Verbatim}

Strings can be concatenated using the \texttt{+} operator or the
\texttt{+=} assignment operator:

\begin{Verbatim}[frame=single]
s := "hi" + string(c)
s += " and good bye"
\end{Verbatim}

String addition creates a new string by concatenating the operands.

For two integer values \texttt{x} and \texttt{y}, the integer quotient
\texttt{q = x / y} and remainder \texttt{r = x \% y} satisfy the
following relationships:

\begin{Verbatim}[frame=single]
x = q*y + r  and  |r| < |y|
\end{Verbatim}

with \texttt{x / y} truncated towards zero
(\href{http://en.wikipedia.org/wiki/Modulo\_operation}{``truncated
division''}).

\begin{Verbatim}[frame=single]
 x     y     x / y     x % y
 5     3       1         2
-5     3      -1        -2
 5    -3      -1         2
-5    -3       1        -2
\end{Verbatim}

As an exception to this rule, if the dividend \texttt{x} is the most
negative value for the int type of \texttt{x}, the quotient
\texttt{q = x / -1} is equal to \texttt{x} (and \texttt{r = 0}).

\begin{Verbatim}[frame=single]
             x, q
int8                     -128
int16                  -32768
int32             -2147483648
int64    -9223372036854775808
\end{Verbatim}

If the divisor is zero, a run-time panic
occurs. If the dividend is positive and the divisor is a constant power
of 2, the division may be replaced by a right shift, and computing the
remainder may be replaced by a bitwise ``and'' operation:

\begin{Verbatim}[frame=single]
 x     x / 4     x % 4     x >> 2     x & 3
 11      2         3         2          3
-11     -2        -3        -3          1
\end{Verbatim}

The shift operators shift the left operand by the shift count specified
by the right operand. They implement arithmetic shifts if the left
operand is a signed integer and logical shifts if it is an unsigned
integer. There is no upper limit on the shift count. Shifts behave as if
the left operand is shifted \texttt{n} times by 1 for a shift count of
\texttt{n}. As a result, \texttt{x \textless{}\textless{} 1} is the same
as \texttt{x*2} and \texttt{x \textgreater{}\textgreater{} 1} is the
same as \texttt{x/2} but truncated towards negative infinity.

For integer operands, the unary operators \texttt{+}, \texttt{-}, and
\texttt{\^{}} are defined as follows:

\begin{Verbatim}[frame=single]
+x                          is 0 + x
-x    negation              is 0 - x
^x    bitwise complement    is m ^ x  with m = "all bits set to 1" for unsigned x
                                      and  m = -1 for signed x
\end{Verbatim}

For floating-point and complex numbers, \texttt{+x} is the same as
\texttt{x}, while \texttt{-x} is the negation of \texttt{x}. The result
of a floating-point or complex division by zero is not specified beyond
the IEEE-754 standard; whether a run-time panic occurs is implementation-specific.

\subsection*{Integer overflow}

For unsigned integer values, the operations \texttt{+}, \texttt{-},
\texttt{*}, and \texttt{\textless{}\textless{}} are computed modulo
2\textsuperscript{\emph{n}}, where \emph{n} is the bit width of the
unsigned integer's type.  Loosely speaking, these unsigned integer
operations discard high bits upon overflow, and programs may rely
on ``wrap around''.

For signed integers, the operations \texttt{+}, \texttt{-}, \texttt{*},
and \texttt{\textless{}\textless{}} may legally overflow and the
resulting value exists and is deterministically defined by the signed
integer representation, the operation, and its operands. No exception is
raised as a result of overflow. A compiler may not optimize code under
the assumption that overflow does not occur. For instance, it may not
assume that \texttt{x \textless{} x + 1} is always true.

\subsection*{Comparison operators}

Comparison operators compare two operands and yield a boolean value.

\begin{Verbatim}[frame=single]
==    equal
!=    not equal
<     less
<=    less or equal
>     greater
>=    greater or equal
\end{Verbatim}

In any comparison, the first operand must be
assignable to the type of the second operand,
or vice versa.

The equality operators \texttt{==} and \texttt{!=} apply to operands
that are \emph{comparable}. The ordering operators \texttt{\textless{}},
\texttt{\textless{}=}, \texttt{\textgreater{}}, and
\texttt{\textgreater{}=} apply to operands that are \emph{ordered}.
These terms and the result of the comparisons are defined as follows:

\begin{itemize}
\item
  Boolean values are comparable. Two boolean values are equal if they
  are either both \texttt{true} or both \texttt{false}.
\item
  Integer values are comparable and ordered, in the usual way.
\item
  Floating point values are comparable and ordered, as defined by the
  IEEE-754 standard.
\item
  Complex values are comparable. Two complex values \texttt{u} and
  \texttt{v} are equal if both \texttt{real(u) == real(v)} and
  \texttt{imag(u) == imag(v)}.
\item
  String values are comparable and ordered, lexically byte-wise.
\item
  Pointer values are comparable. Two pointer values are equal if they
  point to the same variable or if both have value \texttt{nil}.
  Pointers to distinct
  zero-size variables may
  or may not be equal.
\item
  Channel values are comparable. Two channel values are equal if they
  were created by the same call to \texttt{make}
  or if both have value \texttt{nil}.
\item
  Interface values are comparable. Two interface values are equal if
  they have identical dynamic types and equal
  dynamic values or if both have value \texttt{nil}.
\item
  A value \texttt{x} of non-interface type \texttt{X} and a value
  \texttt{t} of interface type \texttt{T} are comparable when values of
  type \texttt{X} are comparable and \texttt{X} implements \texttt{T}.
  They are equal if \texttt{t}'s dynamic type is identical to \texttt{X}
  and \texttt{t}'s dynamic value is equal to \texttt{x}.
\item
  Struct values are comparable if all their fields are comparable. Two
  struct values are equal if their corresponding
  non-blank fields are equal.
\item
  Array values are comparable if values of the array element type are
  comparable. Two array values are equal if their corresponding elements
  are equal.
\end{itemize}

A comparison of two interface values with identical dynamic types causes
a run-time panic if values of that type
are not comparable. This behavior applies not only to direct interface
value comparisons but also when comparing arrays of interface values or
structs with interface-valued fields.

Slice, map, and function values are not comparable. However, as a
special case, a slice, map, or function value may be compared to the
predeclared identifier \texttt{nil}. Comparison of pointer, channel, and
interface values to \texttt{nil} is also allowed and follows from the
general rules above.

The result of a comparison can be assigned to any boolean type. If the
context does not demand a specific boolean type, the result has type
\texttt{bool}.

\begin{Verbatim}[frame=single]
type MyBool bool

var x, y int
var (
    b1 MyBool = x == y // result of comparison has type MyBool
    b2 bool   = x == y // result of comparison has type bool
    b3        = x == y // result of comparison has type bool
)
\end{Verbatim}

\subsection*{Logical operators}

Logical operators apply to boolean values and
yield a result of the same type as the operands. The right operand is
evaluated conditionally.

\begin{Verbatim}[frame=single]
&&    conditional and    p && q  is  "if p then q else false"
||    conditional or     p || q  is  "if p then true else q"
!     not                !p      is  "not p"
\end{Verbatim}

\subsection*{Address operators}

For an operand \texttt{x} of type \texttt{T}, the address operation
\texttt{\&x} generates a pointer of type \texttt{*T} to \texttt{x}. The
operand must be \emph{addressable}, that is, either a variable, pointer
indirection, or slice indexing operation; or a field selector of an
addressable struct operand; or an array indexing operation of an
addressable array. As an exception to the addressability requirement,
\texttt{x} may also be a composite literal.

For an operand \texttt{x} of pointer type \texttt{*T}, the pointer
indirection \texttt{*x} denotes the value of type \texttt{T} pointed to
by \texttt{x}. If \texttt{x} is \texttt{nil}, an attempt to evaluate
\texttt{*x} will cause a run-time panic.

\begin{Verbatim}[frame=single]
&x
&a[f(2)]
*p
*pf(x)
\end{Verbatim}

\subsection*{Receive operator}

For an operand \texttt{ch} of channel type,
the value of the receive operation \texttt{\textless{}-ch} is the value
received from the channel \texttt{ch}. The type of the value is the
element type of the channel. The expression blocks until a value is
available. Receiving from a \texttt{nil} channel blocks forever.
Receiving from a closed channel always succeeds,
immediately returning the element type's
zero value.

\begin{Verbatim}[frame=single]
v1 := <-ch
v2 = <-ch
f(<-ch)
<-strobe  // wait until clock pulse and discard received value
\end{Verbatim}

A receive expression used in an assignment or initialization of the form

\begin{Verbatim}[frame=single]
x, ok = <-ch
x, ok := <-ch
var x, ok = <-ch
\end{Verbatim}

yields an additional result of type \texttt{bool} reporting whether the
communication succeeded. The value of \texttt{ok} is \texttt{true} if
the value received was delivered by a successful send operation to the
channel, or \texttt{false} if it is a zero value generated because the
channel is closed and empty.

\subsection*{Method expressions}

If \texttt{M} is in the method set of type
\texttt{T}, \texttt{T.M} is a function that is callable as a regular
function with the same arguments as \texttt{M} prefixed by an additional
argument that is the receiver of the method.

\begin{Verbatim}[frame=single]
MethodExpr    = ReceiverType "." MethodName .
ReceiverType  = TypeName | "(" "*" TypeName ")" .
\end{Verbatim}

Consider a struct type \texttt{T} with two methods, \texttt{Mv}, whose
receiver is of type \texttt{T}, and \texttt{Mp}, whose receiver is of
type \texttt{*T}.

\begin{Verbatim}[frame=single]
type T struct {
    a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver
var t T
\end{Verbatim}

The expression

\begin{Verbatim}[frame=single]
T.Mv
\end{Verbatim}

yields a function equivalent to \texttt{Mv} but with an explicit
receiver as its first argument; it has signature

\begin{Verbatim}[frame=single]
func(tv T, a int) int
\end{Verbatim}

That function may be called normally with an explicit receiver, so these
three invocations are equivalent:

\begin{Verbatim}[frame=single]
t.Mv(7)
T.Mv(t, 7)
f := T.Mv; f(t, 7)
\end{Verbatim}

Similarly, the expression

\begin{Verbatim}[frame=single]
(*T).Mp
\end{Verbatim}

yields a function value representing \texttt{Mp} with signature

\begin{Verbatim}[frame=single]
func(tp *T, f float32) float32
\end{Verbatim}

For a method with a value receiver, one can derive a function with an
explicit pointer receiver, so

\begin{Verbatim}[frame=single]
(*T).Mv
\end{Verbatim}

yields a function value representing \texttt{Mv} with signature

\begin{Verbatim}[frame=single]
func(tv *T, a int) int
\end{Verbatim}

Such a function indirects through the receiver to create a value to pass
as the receiver to the underlying method; the method does not overwrite
the value whose address is passed in the function call.

The final case, a value-receiver function for a pointer-receiver method,
is illegal because pointer-receiver methods are not in the method set of
the value type.

Function values derived from methods are called with function call
syntax; the receiver is provided as the first argument to the call. That
is, given \texttt{f := T.Mv}, \texttt{f} is invoked as \texttt{f(t, 7)}
not \texttt{t.f(7)}. To construct a function that binds the receiver,
use a closure.

It is legal to derive a function value from a method of an interface
type. The resulting function takes an explicit receiver of that
interface type.

\subsection*{Conversions}

Conversions are expressions of the form \texttt{T(x)} where \texttt{T}
is a type and \texttt{x} is an expression that can be converted to type
\texttt{T}.

\begin{Verbatim}[frame=single]
Conversion = Type "(" Expression ")" .
\end{Verbatim}

If the type starts with an operator it must be parenthesized:

\begin{Verbatim}[frame=single]
*Point(p)        // same as *(Point(p))
(*Point)(p)      // p is converted to (*Point)
<-chan int(c)    // same as <-(chan int(c))
(<-chan int)(c)  // c is converted to (<-chan int)
\end{Verbatim}

A constant value \texttt{x} can be converted to
type \texttt{T} in any of these cases:

\begin{itemize}
\item
  \texttt{x} is representable by a value of type \texttt{T}.
\item
  \texttt{x} is an integer constant and \texttt{T} is a
  string type. The same rule as for
  non-constant \texttt{x} applies in this case.
\end{itemize}

Converting a constant yields a typed constant as result.

\begin{Verbatim}[frame=single]
uint(iota)               // iota value of type uint
float32(2.718281828)     // 2.718281828 of type float32
complex128(1)            // 1.0 + 0.0i of type complex128
string('x')              // "x" of type string
string(0x266c)           // "♬" of type string
MyString("foo" + "bar")  // "foobar" of type MyString
string([]byte{'a'})      // not a constant: []byte{'a'} is not a constant
(*int)(nil)              // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type
int(1.2)                 // illegal: 1.2 cannot be represented as an int
string(65.0)             // illegal: 65.0 is not an integer constant
\end{Verbatim}

A non-constant value \texttt{x} can be converted to type \texttt{T} in
any of these cases:

\begin{itemize}
\item
  \texttt{x} is assignable to \texttt{T}.
\item
  \texttt{x}'s type and \texttt{T} have identical
  underlying types.
\item
  \texttt{x}'s type and \texttt{T} are unnamed pointer types and their
  pointer base types have identical underlying types.
\item
  \texttt{x}'s type and \texttt{T} are both integer or floating point
  types.
\item
  \texttt{x}'s type and \texttt{T} are both complex types.
\item
  \texttt{x} is an integer or has type \texttt{{[}{]}byte} or
  \texttt{{[}{]}rune} and \texttt{T} is a string type.
\item
  \texttt{x} is a string and \texttt{T} is \texttt{{[}{]}byte} or
  \texttt{{[}{]}rune}.
\end{itemize}

Specific rules apply to (non-constant) conversions between numeric types
or to and from a string type. These conversions may change the
representation of \texttt{x} and incur a run-time cost. All other
conversions only change the type but not the representation of
\texttt{x}.

There is no linguistic mechanism to convert between pointers and
integers. The package \texttt{unsafe}
implements this functionality under restricted circumstances.

\paragraph{Conversions between numeric types}

For the conversion of non-constant numeric values, the following rules
apply:

\begin{enumerate}
\item
  When converting between integer types, if the value is a signed
  integer, it is sign extended to implicit infinite precision; otherwise
  it is zero extended. It is then truncated to fit in the result type's
  size. For example, if \texttt{v := uint16(0x10F0)}, then
  \texttt{uint32(int8(v)) == 0xFFFFFFF0}. The conversion always yields a
  valid value; there is no indication of overflow.
\item
  When converting a floating-point number to an integer, the fraction is
  discarded (truncation towards zero).
\item
  When converting an integer or floating-point number to a
  floating-point type, or a complex number to another complex type, the
  result value is rounded to the precision specified by the destination
  type. For instance, the value of a variable \texttt{x} of type
  \texttt{float32} may be stored using additional precision beyond that
  of an IEEE-754 32-bit number, but float32(x) represents the result of
  rounding \texttt{x}'s value to 32-bit precision. Similarly,
  \texttt{x + 0.1} may use more than 32 bits of precision, but
  \texttt{float32(x + 0.1)} does not.
\end{enumerate}

In all non-constant conversions involving floating-point or complex
values, if the result type cannot represent the value the conversion
succeeds but the result value is implementation-dependent.

\paragraph{Conversions to and from a string type}

\begin{enumerate}
\item
  Converting a signed or unsigned integer value to a string type yields
  a string containing the UTF-8 representation of the integer. Values
  outside the range of valid Unicode code points are converted to
  \texttt{"\textbackslash{}uFFFD"}.

\begin{Verbatim}[frame=single]
string('a')       // "a"
string(-1)        // "\ufffd" == "\xef\xbf\xbd"
string(0xf8)      // "\u00f8" == "ø" == "\xc3\xb8"
type MyString string
MyString(0x65e5)  // "\u65e5" == "日" == "\xe6\x97\xa5"
\end{Verbatim}
\item
  Converting a slice of bytes to a string type yields a string whose
  successive bytes are the elements of the slice. If the slice value is
  \texttt{nil}, the result is the empty string.

\begin{Verbatim}[frame=single]
string([]byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'})  // "hellø"

type MyBytes []byte
string(MyBytes{'h', 'e', 'l', 'l', '\xc3', '\xb8'})  // "hellø"
\end{Verbatim}
\item
  Converting a slice of runes to a string type yields a string that is
  the concatenation of the individual rune values converted to strings.
  If the slice value is \texttt{nil}, the result is the empty string.

\begin{Verbatim}[frame=single]
string([]rune{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"

type MyRunes []rune
string(MyRunes{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"
\end{Verbatim}
\item
  Converting a value of a string type to a slice of bytes type yields a
  slice whose successive elements are the bytes of the string. If the
  string is empty, the result is \texttt{{[}{]}byte(nil)}.

\begin{Verbatim}[frame=single]
[]byte("hellø")   // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
MyBytes("hellø")  // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
\end{Verbatim}
\item
  Converting a value of a string type to a slice of runes type yields a
  slice containing the individual Unicode code points of the string. If
  the string is empty, the result is \texttt{{[}{]}rune(nil)}.

\begin{Verbatim}[frame=single]
[]rune(MyString("白鵬翔"))  // []rune{0x767d, 0x9d6c, 0x7fd4}
MyRunes("白鵬翔")           // []rune{0x767d, 0x9d6c, 0x7fd4}
\end{Verbatim}
\end{enumerate}

\subsection*{Constant expressions}

Constant expressions may contain only constant
operands and are evaluated at compile-time.

Untyped boolean, numeric, and string constants may be used as operands
wherever it is legal to use an operand of boolean, numeric, or string
type, respectively. Except for shift operations, if the operands of a
binary operation are different kinds of untyped constants, the operation
and, for non-boolean operations, the result use the kind that appears
later in this list: integer, rune, floating-point, complex. For example,
an untyped integer constant divided by an untyped complex constant
yields an untyped complex constant.

A constant comparison always yields an untyped boolean constant.
If the left operand of a constant shift expression is an untyped
constant, the result is an integer constant; otherwise it is a
constant of the same type as the left operand, which must be of
integer type Applying all other operators to untyped constants
results in an untyped constant of the same kind (that is, a boolean,
integer, floating-point, complex, or string constant).

\begin{Verbatim}[frame=single]
const a = 2 + 3.0          // a == 5.0   (untyped floating-point constant)
const b = 15 / 4           // b == 3     (untyped integer constant)
const c = 15 / 4.0         // c == 3.75  (untyped floating-point constant)
const Θ float64 = 3/2      // Θ == 1.5   (type float64)
const d = 1 << 3.0         // d == 8     (untyped integer constant)
const e = 1.0 << 3         // e == 8     (untyped integer constant)
const f = int32(1) << 33   // f == 0     (type int32)
const g = float64(2) >> 1  // illegal    (float64(2) is a typed floating-point constant)
const h = "foo" > "bar"    // h == true  (untyped boolean constant)
const j = true             // j == true  (untyped boolean constant)
const k = 'w' + 1          // k == 'x'   (untyped rune constant)
const l = "hi"             // l == "hi"  (untyped string constant)
const m = string(k)        // m == "x"   (type string)
const Σ = 1 - 0.707i       //            (untyped complex constant)
const Δ = Σ + 2.0e-4       //            (untyped complex constant)
const Φ = iota*1i - 1/1i   //            (untyped complex constant)
\end{Verbatim}

Applying the built-in function \texttt{complex} to untyped integer,
rune, or floating-point constants yields an untyped complex constant.

\begin{Verbatim}[frame=single]
const ic = complex(0, c)   // ic == 3.75i (untyped complex constant)
const iΘ = complex(0, Θ)   // iΘ == 1.5i  (type complex128)
\end{Verbatim}

Constant expressions are always evaluated exactly; intermediate values
and the constants themselves may require precision significantly larger
than supported by any predeclared type in the language. The following
are legal declarations:

\begin{Verbatim}[frame=single]
const Huge = 1 << 100
const Four int8 = Huge >> 98
\end{Verbatim}

The values of \emph{typed} constants must always be accurately
representable as values of the constant type. The following constant
expressions are illegal:

\begin{Verbatim}[frame=single]
uint(-1)     // -1 cannot be represented as a uint
int(3.14)    // 3.14 cannot be represented as an int
int64(Huge)  // 1<<100 cannot be represented as an int64
Four * 300   // 300 cannot be represented as an int8
Four * 100   // 400 cannot be represented as an int8
\end{Verbatim}

The mask used by the unary bitwise complement operator \texttt{\^{}}
matches the rule for non-constants: the mask is all 1s for unsigned
constants and -1 for signed and untyped constants.

\begin{Verbatim}[frame=single]
^1         // untyped integer constant, equal to -2
uint8(^1)  // error, same as uint8(-2), out of range
^uint8(1)  // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)
int8(^1)   // same as int8(-2)
^int8(1)   // same as -1 ^ int8(1) = -2
\end{Verbatim}

Implementation restriction: A compiler may use rounding while computing
untyped floating-point or complex constant expressions; see the
implementation restriction in the section on
constants. This rounding may cause a
floating-point constant expression to be invalid in an integer context,
even if it would be integral when calculated using infinite precision.

\subsection*{Order of evaluation}

When evaluating the operands of an expression,
assignment, or
return statement, all function calls,
method calls, and communication operations are evaluated in lexical
left-to-right order.

For example, in the assignment

\begin{Verbatim}[frame=single]
y[f()], ok = g(h(), i()+x[j()], <-c), k()
\end{Verbatim}

the function calls and communication happen in the order \texttt{f()},
\texttt{h()}, \texttt{i()}, \texttt{j()}, \texttt{\textless{}-c},
\texttt{g()}, and \texttt{k()}. However, the order of those events
compared to the evaluation and indexing of \texttt{x} and the evaluation
of \texttt{y} is not specified.

\begin{Verbatim}[frame=single]
a := 1
f := func() int { a = 2; return 3 }
x := []int{a, f()}  // x may be [1, 3] or [2, 3]: evaluation order between a and f() is not specified
\end{Verbatim}

Floating-point operations within a single expression are evaluated
according to the associativity of the operators. Explicit parentheses
affect the evaluation by overriding the default associativity. In the
expression \texttt{x + (y + z)} the addition \texttt{y + z} is performed
before adding \texttt{x}.

\section*{Statements}

Statements control execution.

\begin{Verbatim}[frame=single]
Statement =
    Declaration | LabeledStmt | SimpleStmt |
    GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
    FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
    DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
\end{Verbatim}

\subsection*{Empty statements}

The empty statement does nothing.

\begin{Verbatim}[frame=single]
EmptyStmt = .
\end{Verbatim}

\subsection*{Labeled statements}

A labeled statement may be the target of a \texttt{goto}, \texttt{break}
or \texttt{continue} statement.

\begin{Verbatim}[frame=single]
LabeledStmt = Label ":" Statement .
Label       = identifier .
\end{Verbatim}

\begin{Verbatim}[frame=single]
Error: log.Panic("error encountered")
\end{Verbatim}

\subsection*{Expression statements}

Function calls, method calls, and receive operations can appear in
statement context. Such statements may be parenthesized.

\begin{Verbatim}[frame=single]
ExpressionStmt = Expression .
\end{Verbatim}

\begin{Verbatim}[frame=single]
h(x+y)
f.Close()
<-ch
(<-ch)
\end{Verbatim}

\subsection*{Send statements}

A send statement sends a value on a channel. The channel expression must
be of channel type and the type of the value
must be assignable to the channel's element
type.

\begin{Verbatim}[frame=single]
SendStmt = Channel "<-" Expression .
Channel  = Expression .
\end{Verbatim}

Both the channel and the value expression are evaluated before
communication begins. Communication blocks until the send can
proceed. A send on an unbuffered channel can proceed if a receiver
is ready. A send on a buffered channel can proceed if there is room
in the buffer. A send on a closed channel proceeds by causing a
run-time panic. A send on a \texttt{nil} channel blocks forever.

\begin{Verbatim}[frame=single]
ch <- 3
\end{Verbatim}

\subsection*{IncDec statements}

The ``++'' and ``--'' statements increment or decrement their operands
by the untyped constant \texttt{1}. As with an
assignment, the operand must be
addressable or a map index expression.

\begin{Verbatim}[frame=single]
IncDecStmt = Expression ( "++" | "--" ) .
\end{Verbatim}

The following assignment statements are
semantically equivalent:

\begin{Verbatim}[frame=single]
IncDec statement    Assignment
x++                 x += 1
x--                 x -= 1
\end{Verbatim}

\subsection*{Assignments}

\begin{Verbatim}[frame=single]
Assignment = ExpressionList assign_op ExpressionList .

assign_op = [ add_op | mul_op ] "=" .
\end{Verbatim}

Each left-hand side operand must be
addressable, a map index expression, or
the blank identifier. Operands may be
parenthesized.

\begin{Verbatim}[frame=single]
x = 1
*p = f()
a[i] = 23
(k) = <-ch  // same as: k = <-ch
\end{Verbatim}

An \emph{assignment operation} \texttt{x} \emph{op}\texttt{=} \texttt{y}
where \emph{op} is a binary arithmetic operation is equivalent to
\texttt{x} \texttt{=} \texttt{x} \emph{op} \texttt{y} but evaluates
\texttt{x} only once. The \emph{op}\texttt{=} construct is a single
token. In assignment operations, both the left- and right-hand
expression lists must contain exactly one single-valued expression.

\begin{Verbatim}[frame=single]
a[i] <<= 2
i &^= 1<<n
\end{Verbatim}

A tuple assignment assigns the individual elements of a multi-valued
operation to a list of variables. There are two forms. In the first, the
right hand operand is a single multi-valued expression such as a
function evaluation or channel or
map operation or a
type assertion. The number of operands on
the left hand side must match the number of values. For instance, if
\texttt{f} is a function returning two values,

\begin{Verbatim}[frame=single]
x, y = f()
\end{Verbatim}

assigns the first value to \texttt{x} and the second to \texttt{y}. The
blank identifier provides a way to ignore
values returned by a multi-valued expression:

\begin{Verbatim}[frame=single]
x, _ = f()  // ignore second value returned by f()
\end{Verbatim}

In the second form, the number of operands on the left must equal the
number of expressions on the right, each of which must be single-valued,
and the \emph{n}th expression on the right is assigned to the \emph{n}th
operand on the left.

The assignment proceeds in two phases. First, the operands of
index expressions and
pointer indirections (including implicit
pointer indirections in selectors) on the left and
the expressions on the right are all
evaluated in the usual order. Second,
the assignments are carried out in left-to-right order.

\begin{Verbatim}[frame=single]
a, b = b, a  // exchange a and b

x := []int{1, 2, 3}
i := 0
i, x[i] = 1, 2  // set i = 1, x[0] = 2

i = 0
x[i], i = 2, 1  // set x[0] = 2, i = 1

x[0], x[0] = 1, 2  // set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)

x[1], x[3] = 4, 5  // set x[1] = 4, then panic setting x[3] = 5.

type Point struct { x, y int }
var p *Point
x[2], p.x = 6, 7  // set x[2] = 6, then panic setting p.x = 7

i = 2
x = []int{3, 5, 7}
for i, x[i] = range x {  // set i, x[2] = 0, x[0]
    break
}
// after this loop, i == 0 and x == []int{3, 5, 3}
\end{Verbatim}

In assignments, each value must be assignable
to the type of the operand to which it is assigned. If an untyped
constant is assigned to a variable of interface
type, the constant is converted to type
\texttt{bool}, \texttt{rune}, \texttt{int}, \texttt{float64},
\texttt{complex128} or \texttt{string} respectively, depending on
whether the value is a boolean, rune, integer, floating-point, complex,
or string constant.

\subsection*{If statements}

``If'' statements specify the conditional execution of two branches
according to the value of a boolean expression. If the expression
evaluates to true, the ``if'' branch is executed, otherwise, if present,
the ``else'' branch is executed.

\begin{Verbatim}[frame=single]
IfStmt = "if" [ SimpleStmt ";" ] Expression Block [ "else" ( IfStmt | Block ) ] .
\end{Verbatim}

\begin{Verbatim}[frame=single]
if x > max {
    x = max
}
\end{Verbatim}

The expression may be preceded by a simple statement, which executes
before the expression is evaluated.

\begin{Verbatim}[frame=single]
if x := f(); x < y {
    return x
} else if x > z {
    return z
} else {
    return y
}
\end{Verbatim}

\subsection*{Switch statements}

``Switch'' statements provide multi-way execution. An expression or type
specifier is compared to the ``cases'' inside the ``switch'' to
determine which branch to execute.

\begin{Verbatim}[frame=single]
SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
\end{Verbatim}

There are two forms: expression switches and type switches. In an
expression switch, the cases contain expressions that are compared
against the value of the switch expression. In a type switch, the cases
contain types that are compared against the type of a specially
annotated switch expression.

\paragraph{Expression switches}

In an expression switch, the switch expression is evaluated and the case
expressions, which need not be constants, are evaluated left-to-right
and top-to-bottom; the first one that equals the switch expression
triggers execution of the statements of the associated case; the other
cases are skipped. If no case matches and there is a ``default'' case,
its statements are executed. There can be at most one default case and
it may appear anywhere in the ``switch'' statement. A missing switch
expression is equivalent to the expression \texttt{true}.

\begin{Verbatim}[frame=single]
ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .
ExprCaseClause = ExprSwitchCase ":" { Statement ";" } .
ExprSwitchCase = "case" ExpressionList | "default" .
\end{Verbatim}

In a case or default clause, the last statement only may be a
``fallthrough'' statement to indicate that control should flow from
the end of this clause to the first statement of the next clause.
Otherwise control flows to the end of the ``switch'' statement.

The expression may be preceded by a simple statement, which executes
before the expression is evaluated.

\begin{Verbatim}[frame=single]
switch tag {
default: s3()
case 0, 1, 2, 3: s1()
case 4, 5, 6, 7: s2()
}

switch x := f(); {  // missing switch expression means "true"
case x < 0: return -x
default: return x
}

switch {
case x < y: f1()
case x < z: f2()
case x == 4: f3()
}
\end{Verbatim}

\paragraph{Type switches}

A type switch compares types rather than values. It is otherwise similar
to an expression switch. It is marked by a special switch expression
that has the form of a type assertion using
the reserved word \texttt{type} rather than an actual type. Cases then
match literal types against the dynamic type of the expression in the
type assertion.

\begin{Verbatim}[frame=single]
TypeSwitchStmt  = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .
TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .
TypeCaseClause  = TypeSwitchCase ":" { Statement ";" } .
TypeSwitchCase  = "case" TypeList | "default" .
TypeList        = Type { "," Type } .
\end{Verbatim}

The TypeSwitchGuard may include a
short variable declaration.
When that form is used, the variable is declared at the beginning of the
implicit block in each clause. In clauses with a case
listing exactly one type, the variable has that type; otherwise, the
variable has the type of the expression in the TypeSwitchGuard.

The type in a case may be \texttt{nil}; that case is used when the
expression in the TypeSwitchGuard is a \texttt{nil} interface value.

Given an expression \texttt{x} of type \texttt{interface\{\}}, the
following type switch:

\begin{Verbatim}[frame=single]
switch i := x.(type) {
case nil:
    printString("x is nil")
case int:
    printInt(i)  // i is an int
case float64:
    printFloat64(i)  // i is a float64
case func(int) float64:
    printFunction(i)  // i is a function
case bool, string:
    printString("type is bool or string")  // i is an interface{}
default:
    printString("don't know the type")
}
\end{Verbatim}

could be rewritten:

\begin{Verbatim}[frame=single]
v := x  // x is evaluated exactly once
if v == nil {
    printString("x is nil")
} else if i, isInt := v.(int); isInt {
    printInt(i)  // i is an int
} else if i, isFloat64 := v.(float64); isFloat64 {
    printFloat64(i)  // i is a float64
} else if i, isFunc := v.(func(int) float64); isFunc {
    printFunction(i)  // i is a function
} else {
    i1, isBool := v.(bool)
    i2, isString := v.(string)
    if isBool || isString {
        i := v
        printString("type is bool or string")  // i is an interface{}
    } else {
        i := v
        printString("don't know the type")  // i is an interface{}
    }
}
\end{Verbatim}

The type switch guard may be preceded by a simple statement, which
executes before the guard is evaluated.

The ``fallthrough'' statement is not permitted in a type switch.

\subsection*{For statements}

A ``for'' statement specifies repeated execution of a block. The
iteration is controlled by a condition, a ``for'' clause, or a ``range''
clause.

\begin{Verbatim}[frame=single]
ForStmt = "for" [ Condition | ForClause | RangeClause ] Block .
Condition = Expression .
\end{Verbatim}

In its simplest form, a ``for'' statement specifies the repeated
execution of a block as long as a boolean condition evaluates to true.
The condition is evaluated before each iteration. If the condition is
absent, it is equivalent to \texttt{true}.

\begin{Verbatim}[frame=single]
for a < b {
    a *= 2
}
\end{Verbatim}

A ``for'' statement with a ForClause is also controlled by its
condition, but additionally it may specify an \emph{init} and a
\emph{post} statement, such as an assignment, an increment or decrement
statement. The init statement may be a
short variable declaration,
but the post statement must not.

\begin{Verbatim}[frame=single]
ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
InitStmt = SimpleStmt .
PostStmt = SimpleStmt .
\end{Verbatim}

\begin{Verbatim}[frame=single]
for i := 0; i < 10; i++ {
    f(i)
}
\end{Verbatim}

If non-empty, the init statement is executed once before evaluating the
condition for the first iteration; the post statement is executed after
each execution of the block (and only if the block was executed). Any
element of the ForClause may be empty but the
semicolons are required unless there is only a
condition. If the condition is absent, it is equivalent to
\texttt{true}.

\begin{Verbatim}[frame=single]
for cond { S() }    is the same as    for ; cond ; { S() }
for      { S() }    is the same as    for true     { S() }
\end{Verbatim}

A ``for'' statement with a ``range'' clause iterates through all entries
of an array, slice, string or map, or values received on a channel. For
each entry it assigns \emph{iteration values} to corresponding
\emph{iteration variables} and then executes the block.

\begin{Verbatim}[frame=single]
RangeClause = Expression [ "," Expression ] ( "=" | ":=" ) "range" Expression .
\end{Verbatim}

The expression on the right in the ``range'' clause is called the
\emph{range expression}, which may be an array, pointer to an array,
slice, string, map, or channel. As with an assignment, the operands on
the left must be addressable or map index
expressions; they denote the iteration variables. If the range
expression is a channel, only one iteration variable is permitted,
otherwise there may be one or two. If the second iteration variable is
the blank identifier, the range clause is
equivalent to the same clause with only the first variable present.

The range expression is evaluated once before beginning the loop except
if the expression is an array, in which case, depending on the
expression, it might not be evaluated (see below). Function calls on the
left are evaluated once per iteration. For each iteration, iteration
values are produced as follows:

\begin{Verbatim}[frame=single]
Range expression                          1st value          2nd value (if 2nd variable is present)

array or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       E
string          s  string type            index    i  int    see below  rune
map             m  map[K]V                key      k  K      m[k]       V
channel         c  chan E                 element  e  E
\end{Verbatim}

\begin{enumerate}
\item
  For an array, pointer to array, or slice value \texttt{a}, the index
  iteration values are produced in increasing order, starting at element
  index 0. As a special case, if only the first iteration variable is
  present, the range loop produces iteration values from 0 up to
  \texttt{len(a)} and does not index into the array or slice itself. For
  a \texttt{nil} slice, the number of iterations is 0.
\item
  For a string value, the ``range'' clause iterates over the Unicode
  code points in the string starting at byte index 0. On successive
  iterations, the index value will be the index of the first byte of
  successive UTF-8-encoded code points in the string, and the second
  value, of type \texttt{rune}, will be the value of the corresponding
  code point. If the iteration encounters an invalid UTF-8 sequence, the
  second value will be \texttt{0xFFFD}, the Unicode replacement
  character, and the next iteration will advance a single byte in the
  string.
\item
  The iteration order over maps is not specified and is not guaranteed
  to be the same from one iteration to the next. If map entries that
  have not yet been reached are deleted during iteration, the
  corresponding iteration values will not be produced. If map entries
  are inserted during iteration, the behavior is
  implementation-dependent, but the iteration values for each entry will
  be produced at most once. If the map is \texttt{nil}, the number of
  iterations is 0.
\item
  For channels, the iteration values produced are the successive values
  sent on the channel until the channel is closed. If
  the channel is \texttt{nil}, the range expression blocks forever.
\end{enumerate}

The iteration values are assigned to the respective iteration variables
as in an assignment statement.

The iteration variables may be declared by the ``range'' clause using a
form of short variable declaration (\texttt{:=}). In this case their types are set to the
types of the respective iteration values and their
scope ends at the end of the
``for'' statement; they are re-used in each iteration. If the iteration
variables are declared outside the ``for'' statement, after execution
their values will be those of the last iteration.

\begin{Verbatim}[frame=single]
var testdata *struct {
    a *[7]int
}
for i, _ := range testdata.a {
    // testdata.a is never evaluated; len(testdata.a) is constant
    // i ranges from 0 to 6
    f(i)
}

var a [10]string
m := map[string]int{"mon":0, "tue":1, "wed":2, "thu":3, "fri":4, "sat":5, "sun":6}
for i, s := range a {
    // type of i is int
    // type of s is string
    // s == a[i]
    g(i, s)
}

var key string
var val interface {}  // value type of m is assignable to val
for key, val = range m {
    h(key, val)
}
// key == last map key encountered in iteration
// val == map[key]

var ch chan Work = producer()
for w := range ch {
    doWork(w)
}
\end{Verbatim}

\subsection*{Go statements}

A ``go'' statement starts the execution of a function or method call as
an independent concurrent thread of control, or \emph{goroutine}, within
the same address space.

\begin{Verbatim}[frame=single]
GoStmt = "go" Expression .
\end{Verbatim}

The expression must be a call. The function value and parameters are
evaluated as usual in the calling goroutine, but
unlike with a regular call, program execution does not wait for the
invoked function to complete. Instead, the function begins executing
independently in a new goroutine. When the function terminates, its
goroutine also terminates. If the function has any return values, they
are discarded when the function completes.

\begin{Verbatim}[frame=single]
go Server()
go func(ch chan<- bool) { for { sleep(10); ch <- true; }} (c)
\end{Verbatim}

\subsection*{Select statements}

A ``select'' statement chooses which of a set of possible communications
will proceed. It looks similar to a ``switch'' statement but with the
cases all referring to communication operations.

\begin{Verbatim}[frame=single]
SelectStmt = "select" "{" { CommClause } "}" .
CommClause = CommCase ":" { Statement ";" } .
CommCase   = "case" ( SendStmt | RecvStmt ) | "default" .
RecvStmt   = [ Expression [ "," Expression ] ( "=" | ":=" ) ] RecvExpr .
RecvExpr   = Expression .
\end{Verbatim}

RecvExpr must be a receive operation. For
all the cases in the ``select'' statement, the channel expressions are
evaluated in top-to-bottom order, along with any expressions that appear
on the right hand side of send statements. A channel may be
\texttt{nil}, which is equivalent to that case not being present in the
select statement except, if a send, its expression is still evaluated.
If any of the resulting operations can proceed, one of those is chosen
and the corresponding communication and statements are evaluated.
Otherwise, if there is a default case, that executes; if there is no
default case, the statement blocks until one of the communications can
complete. If there are no cases with non-\texttt{nil} channels, the
statement blocks forever. Even if the statement blocks, the channel and
send expressions are evaluated only once, upon entering the select
statement.

Since all the channels and send expressions are evaluated, any side
effects in that evaluation will occur for all the communications in the
``select'' statement.

If multiple cases can proceed, a uniform pseudo-random choice is made to
decide which single communication will execute.

The receive case may declare one or two new variables using a
short variable declaration.

\begin{Verbatim}[frame=single]
var c, c1, c2, c3 chan int
var i1, i2 int
select {
case i1 = <-c1:
    print("received ", i1, " from c1\n")
case c2 <- i2:
    print("sent ", i2, " to c2\n")
case i3, ok := (<-c3):  // same as: i3, ok := <-c3
    if ok {
        print("received ", i3, " from c3\n")
    } else {
        print("c3 is closed\n")
    }
default:
    print("no communication\n")
}

for {  // send random sequence of bits to c
    select {
    case c <- 0:  // note: no statement, no fallthrough, no folding of cases
    case c <- 1:
    }
}

select {}  // block forever
\end{Verbatim}

\subsection*{Return statements}

A ``return'' statement terminates execution of the containing function
and optionally provides a result value or values to the caller.

\begin{Verbatim}[frame=single]
ReturnStmt = "return" [ ExpressionList ] .
\end{Verbatim}

In a function without a result type, a ``return'' statement must not
specify any result values.

\begin{Verbatim}[frame=single]
func noResult() {
    return
}
\end{Verbatim}

There are three ways to return values from a function with a result
type:

\begin{enumerate}
\item
  The return value or values may be explicitly listed in the ``return''
  statement. Each expression must be single-valued and
  assignable to the corresponding element of
  the function's result type.

\begin{Verbatim}[frame=single]
func simpleF() int {
    return 2
}

func complexF1() (re float64, im float64) {
    return -7.0, -4.0
}
\end{Verbatim}
\item
  The expression list in the ``return'' statement may be a single call
  to a multi-valued function. The effect is as if each value returned
  from that function were assigned to a temporary variable with the type
  of the respective value, followed by a ``return'' statement listing
  these variables, at which point the rules of the previous case apply.

\begin{Verbatim}[frame=single]
func complexF2() (re float64, im float64) {
    return complexF1()
}
\end{Verbatim}
\item
  The expression list may be empty if the function's result type
  specifies names for its result parameters. The result parameters
  act as ordinary local variables and the function may assign values to
  them as necessary. The ``return'' statement returns the values of
  these variables.

\begin{Verbatim}[frame=single]
func complexF3() (re float64, im float64) {
    re = 7.0
    im = 4.0
    return
}

func (devnull) Write(p []byte) (n int, _ error) {
    n = len(p)
    return
}
\end{Verbatim}
\end{enumerate}

Regardless of how they are declared, all the result values are
initialized to the zero values for their type upon entry to the
function.

\subsection*{Break statements}

A ``break'' statement terminates execution of the innermost ``for'',
``switch'' or ``select'' statement.

\begin{Verbatim}[frame=single]
BreakStmt = "break" [ Label ] .
\end{Verbatim}

If there is a label, it must be that of an enclosing ``for'', ``switch''
or ``select'' statement, and that is the one whose execution terminates.

\begin{Verbatim}[frame=single]
L:
    for i < n {
        switch i {
        case 5:
            break L
        }
    }
\end{Verbatim}

\subsection*{Continue statements}

A ``continue'' statement begins the next iteration of the innermost
``for'' loop at its post statement.

\begin{Verbatim}[frame=single]
ContinueStmt = "continue" [ Label ] .
\end{Verbatim}

If there is a label, it must be that of an enclosing ``for'' statement,
and that is the one whose execution advances.

\subsection*{Goto statements}

A ``goto'' statement transfers control to the statement with the
corresponding label.

\begin{Verbatim}[frame=single]
GotoStmt = "goto" Label .
\end{Verbatim}

\begin{Verbatim}[frame=single]
goto Error
\end{Verbatim}

Executing the ``goto'' statement must not cause any variables to come
into scope that were not already in
scope at the point of the goto. For instance, this example:

\begin{Verbatim}[frame=single]
    goto L  // BAD
    v := 3
L:
\end{Verbatim}

is erroneous because the jump to label \texttt{L} skips the creation of
\texttt{v}.

A ``goto'' statement outside a block cannot jump to a
label inside that block. For instance, this example:

\begin{Verbatim}[frame=single]
if n%2 == 1 {
    goto L1
\}
for n > 0 {
    f()
    n--
L1:
    f()
    n--
\}
\end{Verbatim}

is erroneous because the label \texttt{L1} is inside the ``for''
statement's block but the \texttt{goto} is not.

\subsection*{Fallthrough statements}

A ``fallthrough'' statement transfers control to the first statement of
the next case clause in a expression ``switch'' statement. It may be used
only as the final non-empty statement in a case or default clause in an
expression ``switch'' statement.

\begin{Verbatim}[frame=single]
FallthroughStmt = "fallthrough" .
\end{Verbatim}

\subsection*{Defer statements}

A ``defer'' statement invokes a function whose execution is deferred to
the moment the surrounding function returns.

\begin{Verbatim}[frame=single]
DeferStmt = "defer" Expression .
\end{Verbatim}

The expression must be a function or method call. Each time the
``defer'' statement executes, the function value and parameters to the
call are evaluated as usual and saved anew but the
actual function is not invoked. Instead, deferred calls are executed in
LIFO order immediately before the surrounding function returns, after
the return values, if any, have been evaluated, but before they are
returned to the caller. For instance, if the deferred function is a
function literal and the surrounding
function has named result parameters that
are in scope within the literal, the deferred function may access and
modify the result parameters before they are returned. If the deferred
function has any return values, they are discarded when the function
completes.

\begin{Verbatim}[frame=single]
lock(l)
defer unlock(l)  // unlocking happens before surrounding function returns

// prints 3 2 1 0 before surrounding function returns
for i := 0; i <= 3; i++ {
    defer fmt.Print(i)
}

// f returns 1
func f() (result int) {
    defer func() {
        result++
    }()
    return 0
}
\end{Verbatim}

\section*{Built-in functions}

Built-in functions are predeclared.
They are called like any other function but some of them accept a type
instead of an expression as the first argument.

The built-in functions do not have standard Go types, so they can only
appear in call expressions; they cannot be used as
function values.

\begin{Verbatim}[frame=single]
BuiltinCall = identifier "(" [ BuiltinArgs [ "," ] ] ")" .
BuiltinArgs = Type [ "," ExpressionList ] | ExpressionList .
\end{Verbatim}

\subsection*{Close}

For a channel \texttt{c}, the built-in function \texttt{close(c)}
records that no more values will be sent on the channel. It is an
error if \texttt{c} is a receive-only channel. Sending to or closing
a closed channel causes a run-time panic. Closing the nil channel
also causes a run-time panic. After calling \texttt{close}, and
after any previously sent values have been received, receive
operations will return the zero value for the channel's type without
blocking. The multi-valued receive operation returns a received
value along with an indication of whether the channel is closed.

\subsection*{Length and capacity}

The built-in functions \texttt{len} and \texttt{cap} take arguments of
various types and return a result of type \texttt{int}. The
implementation guarantees that the result always fits into an
\texttt{int}.

\begin{Verbatim}[frame=single]
Call      Argument type    Result

len(s)    string type      string length in bytes
          [n]T, *[n]T      array length (== n)
          []T              slice length
          map[K]T          map length (number of defined keys)
          chan T           number of elements queued in channel buffer

cap(s)    [n]T, *[n]T      array length (== n)
          []T              slice capacity
          chan T           channel buffer capacity
\end{Verbatim}

The capacity of a slice is the number of elements for which there is
space allocated in the underlying array. At any time the following
relationship holds:

\begin{Verbatim}[frame=single]
0 <= len(s) <= cap(s)
\end{Verbatim}

The length and capacity of a \texttt{nil} slice, map, or channel are 0.

The expression \texttt{len(s)} is constant if \texttt{s} is a string
constant. The expressions \texttt{len(s)} and \texttt{cap(s)} are
constants if the type of \texttt{s} is an array or pointer to an
array and the expression \texttt{s} does not contain channel receives
or function calls; in this case \texttt{s} is not evaluated.
Otherwise, invocations of \texttt{len} and \texttt{cap} are not
constant and \texttt{s} is evaluated.

\subsection*{Allocation}

The built-in function \texttt{new} takes a type \texttt{T} and returns a
value of type \texttt{*T}. The memory is initialized as described in the
section on initial values.

\begin{Verbatim}[frame=single]
new(T)
\end{Verbatim}

For instance

\begin{Verbatim}[frame=single]
type S struct { a int; b float64 }
new(S)
\end{Verbatim}

dynamically allocates memory for a variable of type \texttt{S},
initializes it (\texttt{a=0}, \texttt{b=0.0}), and returns a value of
type \texttt{*S} containing the address of the memory.

\subsection*{Making slices, maps and channels}

Slices, maps and channels are reference types that do not require the
extra indirection of an allocation with \texttt{new}. The built-in
function \texttt{make} takes a type \texttt{T}, which must be a slice,
map or channel type, optionally followed by a type-specific list of
expressions. It returns a value of type \texttt{T} (not \texttt{*T}).
The memory is initialized as described in the section on initial values.

\begin{Verbatim}[frame=single]
Call             Type T     Result

make(T, n)       slice      slice of type T with length n and capacity n
make(T, n, m)    slice      slice of type T with length n and capacity m

make(T)          map        map of type T
make(T, n)       map        map of type T with initial space for n elements

make(T)          channel    synchronous channel of type T
make(T, n)       channel    asynchronous channel of type T, buffer size n
\end{Verbatim}

The arguments \texttt{n} and \texttt{m} must be of integer type. A
run-time panic occurs if \texttt{n} is
negative or larger than \texttt{m}, or if \texttt{n} or \texttt{m}
cannot be represented by an \texttt{int}.

\begin{Verbatim}[frame=single]
s := make([]int, 10, 100)       // slice with len(s) == 10, cap(s) == 100
s := make([]int, 10)            // slice with len(s) == cap(s) == 10
c := make(chan int, 10)         // channel with a buffer size of 10
m := make(map[string]int, 100)  // map with initial space for 100 elements
\end{Verbatim}

\subsection*{Appending to and copying slices}

Two built-in functions assist in common slice operations.

The variadic function \texttt{append} appends zero or more values
\texttt{x} to \texttt{s} of type \texttt{S}, which must be a slice
type, and returns the resulting slice, also of type \texttt{S}. The
values \texttt{x} are passed to a parameter of type \texttt{...T}
where \texttt{T} is the element type of \texttt{S} and the respective
parameter passing rules apply. As a special case, \texttt{append}
also accepts a first argument assignable to type \texttt{{[}{]}byte}
with a second argument of string type followed by \texttt{...}.
This form appends the bytes of the string.

\begin{Verbatim}[frame=single]
append(s S, x ...T) S  // T is the element type of S
\end{Verbatim}

If the capacity of \texttt{s} is not large enough to fit the additional
values, \texttt{append} allocates a new, sufficiently large slice that
fits both the existing slice elements and the additional values. Thus,
the returned slice may refer to a different underlying array.

\begin{Verbatim}[frame=single]
s0 := []int{0, 0}
s1 := append(s0, 2)        // append a single element     s1 == []int{0, 0, 2}
s2 := append(s1, 3, 5, 7)  // append multiple elements    s2 == []int{0, 0, 2, 3, 5, 7}
s3 := append(s2, s0...)    // append a slice              s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}

var t []interface{}
t = append(t, 42, 3.1415, "foo")                          t == []interface{}{42, 3.1415, "foo"}

var b []byte
b = append(b, "bar"...)  // append string contents      b == []byte{'b', 'a', 'r' }
\end{Verbatim}

The function \texttt{copy} copies slice elements from a source
\texttt{src} to a destination \texttt{dst} and returns the number of
elements copied. Source and destination may overlap. Both arguments must
have identical element type \texttt{T} and
must be assignable to a slice of type
\texttt{{[}{]}T}. The number of elements copied is the minimum of
\texttt{len(src)} and \texttt{len(dst)}. As a special case,
\texttt{copy} also accepts a destination argument assignable to type
\texttt{{[}{]}byte} with a source argument of a string type. This form
copies the bytes from the string into the byte slice.

\begin{Verbatim}[frame=single]
copy(dst, src []T) int
copy(dst []byte, src string) int
\end{Verbatim}

Examples:

\begin{Verbatim}[frame=single]
var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
var b = make([]byte, 5)
n1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}
n2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}
n3 := copy(b, "Hello, World!")  // n3 == 5, b == []byte("Hello")
\end{Verbatim}

\subsection*{Deletion of map elements}

The built-in function \texttt{delete} removes the element with key
\texttt{k} from a map \texttt{m}. The type of
\texttt{k} must be assignable to the key type
of \texttt{m}.

\begin{Verbatim}[frame=single]
delete(m, k)  // remove element m[k] from map m
\end{Verbatim}

If the element \texttt{m{[}k{]}} does not exist, \texttt{delete} is a
no-op. Calling \texttt{delete} with a nil map causes a
run-time panic.

\subsection*{Manipulating complex numbers}

Three functions assemble and disassemble complex numbers. The built-in
function \texttt{complex} constructs a complex value from a
floating-point real and imaginary part, while \texttt{real} and
\texttt{imag} extract the real and imaginary parts of a complex value.

\begin{Verbatim}[frame=single]
complex(realPart, imaginaryPart floatT) complexT
real(complexT) floatT
imag(complexT) floatT
\end{Verbatim}

The type of the arguments and return value correspond. For
\texttt{complex}, the two arguments must be of the same floating-point
type and the return type is the complex type with the corresponding
floating-point constituents: \texttt{complex64} for \texttt{float32},
\texttt{complex128} for \texttt{float64}. The \texttt{real} and
\texttt{imag} functions together form the inverse, so for a complex
value \texttt{z}, \texttt{z} \texttt{==} \texttt{complex(real(z),}
\texttt{imag(z))}.

If the operands of these functions are all constants, the return value
is a constant.

\begin{Verbatim}[frame=single]
var a = complex(2, -2)             // complex128
var b = complex(1.0, -1.4)         // complex128
x := float32(math.Cos(math.Pi/2))  // float32
var c64 = complex(5, -x)           // complex64
var im = imag(b)                   // float64
var rl = real(c64)                 // float32
\end{Verbatim}

\subsection*{Handling panics}

Two built-in functions, \texttt{panic} and \texttt{recover}, assist in
reporting and handling run-time panics and
program-defined error conditions.

\begin{Verbatim}[frame=single]
func panic(interface{})
func recover() interface{}
\end{Verbatim}

When a function \texttt{F} calls \texttt{panic}, normal execution
of \texttt{F} stops immediately. Any functions whose execution was
deferred by the invocation of \texttt{F} are run in the usual way,
and then \texttt{F} returns to its caller. To the caller, \texttt{F}
then behaves like a call to \texttt{panic}, terminating its own
execution and running deferred functions. This continues until all
functions in the goroutine have ceased execution, in reverse order.
At that point, the program is terminated and the error condition
is reported, including the value of the argument to \texttt{panic}.
This termination sequence is called \emph{panicking}.

\begin{Verbatim}[frame=single]
panic(42)
panic("unreachable")
panic(Error("cannot parse"))
\end{Verbatim}

The \texttt{recover} function allows a program to manage behavior of a
panicking goroutine. Executing a \texttt{recover} call \emph{inside} a
deferred function (but not any function called by it) stops the
panicking sequence by restoring normal execution, and retrieves the
error value passed to the call of \texttt{panic}. If \texttt{recover} is
called outside the deferred function it will not stop a panicking
sequence. In this case, or when the goroutine is not panicking, or if
the argument supplied to \texttt{panic} was \texttt{nil},
\texttt{recover} returns \texttt{nil}.

The \texttt{protect} function in the example below invokes the function
argument \texttt{g} and protects callers from run-time panics raised by
\texttt{g}.

\begin{Verbatim}[frame=single]
func protect(g func()) {
    defer func() {
        log.Println("done")  // Println executes normally even if there is a panic
        if x := recover(); x != nil {
            log.Printf("run time panic: %v", x)
        }
    }()
    log.Println("start")
    g()
}
\end{Verbatim}

\subsection*{Bootstrapping}

Current implementations provide several built-in functions useful during
bootstrapping. These functions are documented for completeness but are
not guaranteed to stay in the language. They do not return a result.

\begin{Verbatim}[frame=single]
Function   Behavior

print      prints all arguments; formatting of arguments is implementation-specific
println    like print but prints spaces between arguments and a newline at the end
\end{Verbatim}

\section*{Packages}

Go programs are constructed by linking together \emph{packages}. A
package in turn is constructed from one or more source files that
together declare constants, types, variables and functions belonging to
the package and which are accessible in all files of the same package.
Those elements may be exported and
used in another package.

\subsection*{Source file organization}

Each source file consists of a package clause defining the package to
which it belongs, followed by a possibly empty set of import
declarations that declare packages whose contents it wishes to use,
followed by a possibly empty set of declarations of functions, types,
variables, and constants.

\begin{Verbatim}[frame=single]
SourceFile       = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
\end{Verbatim}

\subsection*{Package clause}

A package clause begins each source file and defines the package to
which the file belongs.

\begin{Verbatim}[frame=single]
PackageClause  = "package" PackageName .
PackageName    = identifier .
\end{Verbatim}

The PackageName must not be the blank identifier.

\begin{Verbatim}[frame=single]
package math
\end{Verbatim}

A set of files sharing the same PackageName form the implementation of a
package. An implementation may require that all source files for a
package inhabit the same directory.

\subsection*{Import declarations}

An import declaration states that the source file containing the
declaration depends on functionality of the \emph{imported} package
and it enables access to exported identifiers of that package.  The
import names an identifier (PackageName) to be used for access and
an ImportPath that specifies the package to be imported.

\begin{Verbatim}[frame=single]
ImportDecl       = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
ImportSpec       = [ "." | PackageName ] ImportPath .
ImportPath       = string_lit .
\end{Verbatim}

The PackageName is used in qualified identifiers to access exported
identifiers of the package within the importing source file. It is
declared in the file block. If the PackageName is omitted, it
defaults to the identifier specified in the package clause of the
imported package. If an explicit period (\texttt{.}) appears instead
of a name, all the package's exported identifiers declared in that
package's package block will be declared in the importing source
file's file block and can be accessed without a qualifier.

The interpretation of the ImportPath is implementation-dependent but it
is typically a substring of the full file name of the compiled package
and may be relative to a repository of installed packages.

Implementation restriction: A compiler may restrict ImportPaths to
non-empty strings using only characters belonging to
\href{http://www.unicode.org/versions/Unicode6.0.0/}{Unicode's} L, M, N,
P, and S general categories (the Graphic characters without spaces) and
may also exclude the characters
\texttt{!"\#\$\%\&'()*,:;\textless{}=\textgreater{}?{[}\textbackslash{}{]}\^{}`\{\textbar{}\}}
and the Unicode replacement character U+FFFD.

Assume we have compiled a package containing the package clause
\texttt{package math}, which exports function \texttt{Sin}, and
installed the compiled package in the file identified by
\texttt{"lib/math"}. This table illustrates how \texttt{Sin} may be
accessed in files that import the package after the various types of
import declaration.

\begin{Verbatim}[frame=single]
Import declaration          Local name of Sin

import   "lib/math"         math.Sin
import M "lib/math"         M.Sin
import . "lib/math"         Sin
\end{Verbatim}

An import declaration declares a dependency relation between the
importing and imported package. It is illegal for a package to import
itself or to import a package without referring to any of its exported
identifiers. To import a package solely for its side-effects
(initialization), use the blank identifier
as explicit package name:

\begin{Verbatim}[frame=single]
import _ "lib/math"
\end{Verbatim}

\subsection*{An example package}

Here is a complete Go package that implements a concurrent prime sieve.

\begin{Verbatim}[frame=single]
package main

import "fmt"

// Send the sequence 2, 3, 4, … to channel 'ch'.
func generate(ch chan<- int) {
    for i := 2; ; i++ {
        ch <- i  // Send 'i' to channel 'ch'.
    }
}

// Copy the values from channel 'src' to channel 'dst',
// removing those divisible by 'prime'.
func filter(src <-chan int, dst chan<- int, prime int) {
    for i := range src {  // Loop over values received from 'src'.
        if i%prime != 0 {
            dst <- i  // Send 'i' to channel 'dst'.
        }
    }
}

// The prime sieve: Daisy-chain filter processes together.
func sieve() {
    ch := make(chan int)  // Create a new channel.
    go generate(ch)       // Start generate() as a subprocess.
    for {
        prime := <-ch
        fmt.Print(prime, "\n")
        ch1 := make(chan int)
        go filter(ch, ch1, prime)
        ch = ch1
    }
}

func main() {
    sieve()
}
\end{Verbatim}

\section*{Program initialization and execution}

\subsection*{The zero value}

When memory is allocated to store a value, either through a declaration
or a call of \texttt{make} or \texttt{new}, and no explicit
initialization is provided, the memory is given a default
initialization. Each element of such a value is set to the \emph{zero
value} for its type: \texttt{false} for booleans, \texttt{0} for
integers, \texttt{0.0} for floats, \texttt{""} for strings, and
\texttt{nil} for pointers, functions, interfaces, slices, channels, and
maps. This initialization is done recursively, so for instance each
element of an array of structs will have its fields zeroed if no value
is specified.

These two simple declarations are equivalent:

\begin{Verbatim}[frame=single]
var i int
var i int = 0
\end{Verbatim}

After

\begin{Verbatim}[frame=single]
type T struct { i int; f float64; next *T }
t := new(T)
\end{Verbatim}

the following holds:

\begin{Verbatim}[frame=single]
t.i == 0
t.f == 0.0
t.next == nil
\end{Verbatim}

The same would also be true after

\begin{Verbatim}[frame=single]
var t T
\end{Verbatim}

\subsection*{Program execution}

A package with no imports is initialized by assigning initial values to
all its package-level variables and then calling any package-level
function with the name and signature of

\begin{Verbatim}[frame=single]
func init()
\end{Verbatim}

defined in its source. A package may contain multiple \texttt{init}
functions, even within a single source file; they execute in unspecified
order.

Within a package, package-level variables are initialized, and constant
values are determined, in data-dependent order: if the initializer of
\texttt{A} depends on the value of \texttt{B}, \texttt{A} will be set
after \texttt{B}. It is an error if such dependencies form a cycle.
Dependency analysis is done lexically: \texttt{A} depends on \texttt{B}
if the value of \texttt{A} contains a mention of \texttt{B}, contains a
value whose initializer mentions \texttt{B}, or mentions a function that
mentions \texttt{B}, recursively. If two items are not interdependent,
they will be initialized in the order they appear in the source. Since
the dependency analysis is done per package, it can produce unspecified
results if \texttt{A}'s initializer calls a function defined in another
package that refers to \texttt{B}.

An \texttt{init} function cannot be referred to from anywhere in a
program. In particular, \texttt{init} cannot be called explicitly, nor
can a pointer to \texttt{init} be assigned to a function variable.

If a package has imports, the imported packages are initialized before
initializing the package itself. If multiple packages import a package
\texttt{P}, \texttt{P} will be initialized only once.

The importing of packages, by construction, guarantees that there can be
no cyclic dependencies in initialization.

A complete program is created by linking a single, unimported package
called the \emph{main package} with all the packages it imports,
transitively. The main package must have package name \texttt{main} and
declare a function \texttt{main} that takes no arguments and returns no
value.

\begin{Verbatim}[frame=single]
func main() { … }
\end{Verbatim}

Program execution begins by initializing the main package and then
invoking the function \texttt{main}. When the function \texttt{main}
returns, the program exits. It does not wait for other
(non-\texttt{main}) goroutines to complete.

Package initialization---variable initialization and the invocation of
\texttt{init} functions---happens in a single goroutine, sequentially,
one package at a time. An \texttt{init} function may launch other
goroutines, which can run concurrently with the initialization code.
However, initialization always sequences the \texttt{init} functions: it
will not start the next \texttt{init} until the previous one has
returned.

\section*{Errors}

The predeclared type \texttt{error} is defined as

\begin{Verbatim}[frame=single]
type error interface {
    Error() string
}
\end{Verbatim}

It is the conventional interface for representing an error condition,
with the nil value representing no error. For instance, a function to
read data from a file might be defined:

\begin{Verbatim}[frame=single]
func Read(f *File, b []byte) (n int, err error)
\end{Verbatim}

\section*{Run-time panics}

Execution errors such as attempting to index an array out of bounds
trigger a \emph{run-time panic} equivalent to a call of the built-in
function \texttt{panic} with a value of the
implementation-defined interface type \texttt{runtime.Error}. That type
satisfies the predeclared interface type
\texttt{error}. The exact error values that represent
distinct run-time error conditions are unspecified.

\begin{Verbatim}[frame=single]
package runtime

type Error interface {
    error
    // and perhaps other methods
}
\end{Verbatim}

\section*{System considerations}

\subsection*{Package \texttt{unsafe}}

The built-in package \texttt{unsafe}, known to the compiler, provides
facilities for low-level programming including operations that violate
the type system. A package using \texttt{unsafe} must be vetted manually
for type safety. The package provides the following interface:

\begin{Verbatim}[frame=single]
package unsafe

type ArbitraryType int  // shorthand for an arbitrary Go type; it is not a real type
type Pointer *ArbitraryType

func Alignof(variable ArbitraryType) uintptr
func Offsetof(selector ArbitraryType) uintptr
func Sizeof(variable ArbitraryType) uintptr
\end{Verbatim}

Any pointer or value of underlying type
\texttt{uintptr} can be converted into a \texttt{Pointer} and vice
versa.

The function \texttt{Sizeof} takes an expression denoting a variable of
any type and returns the size of the variable in bytes.

The function \texttt{Offsetof} takes a selector denoting a struct
field of any type and returns the field offset in bytes relative
to the struct's address.  For a struct \texttt{s} with field
\texttt{f}:

\begin{Verbatim}[frame=single]
uintptr(unsafe.Pointer(&s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(&s.f))
\end{Verbatim}

Computer architectures may require memory addresses to be
\emph{aligned}; that is, for addresses of a variable to be a multiple of
a factor, the variable's type's \emph{alignment}. The function
\texttt{Alignof} takes an expression denoting a variable of any type and
returns the alignment of the (type of the) variable in bytes. For a
variable \texttt{x}:

\begin{Verbatim}[frame=single]
uintptr(unsafe.Pointer(&x)) % unsafe.Alignof(x) == 0
\end{Verbatim}

Calls to \texttt{Alignof}, \texttt{Offsetof}, and \texttt{Sizeof} are
compile-time constant expressions of type \texttt{uintptr}.

\subsection*{Size and alignment guarantees}

For the numeric types, the following sizes are guaranteed:

\begin{Verbatim}[frame=single]
type                                 size in bytes

byte, uint8, int8                     1
uint16, int16                         2
uint32, int32, float32                4
uint64, int64, float64, complex64     8
complex128                           16
\end{Verbatim}

The following minimal alignment properties are guaranteed:

\begin{enumerate}
\item
  For a variable \texttt{x} of any type: \texttt{unsafe.Alignof(x)} is
  at least 1.
\item
  For a variable \texttt{x} of struct type: \texttt{unsafe.Alignof(x)}
  is the largest of all the values \texttt{unsafe.Alignof(x.f)} for each
  field \texttt{f} of \texttt{x}, but at least 1.
\item
  For a variable \texttt{x} of array type: \texttt{unsafe.Alignof(x)} is
  the same as \texttt{unsafe.Alignof(x{[}0{]})}, but at least 1.
\end{enumerate}

A struct or array type has size zero if it contains no fields (or
elements, respectively) that have a size greater than zero. Two distinct
zero-size variables may have the same address in memory.
